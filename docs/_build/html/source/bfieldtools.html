<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>bfieldtools package &#8212; bfieldtools 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="API Reference" href="modules.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          bfieldtools</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../readme.html">Readme</a></li>
                <li><a href="../literature.html">Literature</a></li>
                <li><a href="../auto_examples/index.html">Example gallery</a></li>
                <li><a href="modules.html">API Reference</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Readme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../literature.html">Literature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Example gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#coil-design">Coil design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#thermal-noise-computation">Thermal noise computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#validation">Validation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Reference</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="bfieldtools-package">
<h1>bfieldtools package<a class="headerlink" href="#bfieldtools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bfieldtools.bfield_line">
<span id="bfieldtools-bfield-line-module"></span><h2>bfieldtools.bfield_line module<a class="headerlink" href="#module-bfieldtools.bfield_line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.bfield_line.bfield_current_loops">
<code class="descclassname">bfieldtools.bfield_line.</code><code class="descname">bfield_current_loops</code><span class="sig-paren">(</span><em>vertices</em>, <em>points</em>, <em>loops</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.bfield_line.bfield_current_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>B field for segmented current loops</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
<dt><strong>loops: list</strong></dt><dd><p>list of ordered indices defining closed loops of vertices,
if None use all vertices in the order of vertices.
Example: Giving array of 4 vertices, the closed loop can be
defined as loops = np.array([[0,1,2,3,0]])</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.bfield_line.bfield_line_segments">
<code class="descclassname">bfieldtools.bfield_line.</code><code class="descname">bfield_line_segments</code><span class="sig-paren">(</span><em>vertices</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.bfield_line.bfield_line_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute b field of a segmented line current.
This calculation is based on integration by Griffiths
on page 217 (3rd edition)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points:   (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bfield: (N_points, 3) array</strong></dt><dd><p>Magnetic field at evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.bfield_line.flux_current_loops">
<code class="descclassname">bfieldtools.bfield_line.</code><code class="descname">flux_current_loops</code><span class="sig-paren">(</span><em>vertices</em>, <em>loops</em>, <em>vertices_other</em>, <em>Nquad=2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.bfield_line.flux_current_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute magnetic flux created by a segmented line current loops
(vertices, loops) on a another closed loop of segmented current
(vertices_other). The other loop is numerically integrated.</p>
<p>In other words, calculate mutual inductance of the current loops.</p>
<p>NOT SUITABLE for calculating the self-flux, i.e., self inductance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices:</strong></dt><dd><p>all vertices in segmented loops generating the flux</p>
</dd>
<dt><strong>loops:</strong></dt><dd><p>list of indices defining closed loops of vertices, if
None use all vertices. All loops must have the same
number of indices (this could be changed in future)
Example: Giving array of 4 vertices, the loops can be
defined as loops = np.array([[0,1,2,3]])</p>
</dd>
<dt><strong>vertices_other:</strong></dt><dd><p>vertices in the loop receiving the flux</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>flux in the other loop generated by loops (Nloops,)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.bfield_line.mycross">
<code class="descclassname">bfieldtools.bfield_line.</code><code class="descname">mycross</code><span class="sig-paren">(</span><em>r1</em>, <em>r2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.bfield_line.mycross" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross product without overhead</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.bfield_line.vectorpot_current_loops">
<code class="descclassname">bfieldtools.bfield_line.</code><code class="descname">vectorpot_current_loops</code><span class="sig-paren">(</span><em>vertices</em>, <em>points</em>, <em>loops=None</em>, <em>reg=1e-12</em>, <em>symmetrize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.bfield_line.vectorpot_current_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential of a segmented line currents.
Based on straightforward integration of 1/r potential over a line
i.e. the gamma0 integral</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
<dt><strong>loops: list</strong></dt><dd><p>list of ordered indices defining closed loops of vertices,
if None use all vertices in the order of vertices.
All loops must have the same number of indices
(this could be changed in future)
Example: Giving array of 4 vertices, a closed loop can be
defined as loops = np.array([[0,1,2,3]])</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Vector potential (Nloops, Npoints, 3)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.coil_optimize">
<span id="bfieldtools-coil-optimize-module"></span><h2>bfieldtools.coil_optimize module<a class="headerlink" href="#module-bfieldtools.coil_optimize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.coil_optimize.cvxopt_solve_qp">
<code class="descclassname">bfieldtools.coil_optimize.</code><code class="descname">cvxopt_solve_qp</code><span class="sig-paren">(</span><em>P</em>, <em>q</em>, <em>G=None</em>, <em>h=None</em>, <em>A=None</em>, <em>b=None</em>, <em>sw=None</em>, <em>reg=None</em>, <em>tolerance=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxopt_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use cvxopt to minimize
(1/2) * x’ * P * x + q’ * x</p>
<p>subject to
G * x &lt;= h</p>
<p>and
A * x = b</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.cvxpy_solve_qp">
<code class="descclassname">bfieldtools.coil_optimize.</code><code class="descname">cvxpy_solve_qp</code><span class="sig-paren">(</span><em>P</em>, <em>G</em>, <em>h</em>, <em>solver='MOSEK'</em>, <em>tolerance=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxpy_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.optimize_streamfunctions">
<code class="descclassname">bfieldtools.coil_optimize.</code><code class="descname">optimize_streamfunctions</code><span class="sig-paren">(</span><em>meshobj</em>, <em>bfield_specification</em>, <em>objective='minimum_inductive_energy'</em>, <em>solver=None</em>, <em>solver_opts={}</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.optimize_streamfunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic optimization of coil stream function according to a specified objective,
while keeping specified target field at target points within given constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshobj: MeshWrapper object</strong></dt><dd><p>Contains Trimesh mesh</p>
</dd>
<dt><strong>bfield_specification: list</strong></dt><dd><p>List in which element is a dictionary containing a field specification.
Each dict contains:
C: Coupling matrix (N_r, N_verts, 3)
target_field: (N_r, 3)
abs_error: float or (N_r, 3)
rel_error: float or (N_r, 3)</p>
</dd>
<dt><strong>objective: string or dict</strong></dt><dd><p>if string, either ‘minimum_inductive_energy’ or ‘minimum_resistive_energy’
if tuple, should contain: (a, b), where a and b are floats describing the inductive and resitive weighting factors.
The resistance matrix is scaled according to the largest singular value of the inductance matrix for consistent behavior
across meshes.</p>
</dd>
<dt><strong>solver</strong></dt><dd></dd>
<dt><strong>tolerance: float</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>I: vector</strong></dt><dd><p>Vector with length len(<cite>meshobj.mesh.vertices</cite>), containing the optimized current density values
at each mesh vertex</p>
</dd>
<dt><strong>sol: dict</strong></dt><dd><p>Dict containing solution info and diagnostics supplied by cvxopt</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.quadprog_solve_qp">
<code class="descclassname">bfieldtools.coil_optimize.</code><code class="descname">quadprog_solve_qp</code><span class="sig-paren">(</span><em>P</em>, <em>q</em>, <em>G=None</em>, <em>h=None</em>, <em>A=None</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.quadprog_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use quadprog to minimize
(1/2) * x’ * P * x + q’ * x</p>
<p>subject to
G * x &lt;= h</p>
<p>and
A * x = b</p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.contour">
<span id="bfieldtools-contour-module"></span><h2>bfieldtools.contour module<a class="headerlink" href="#module-bfieldtools.contour" title="Permalink to this headline">¶</a></h2>
<p>This module includes functions for creating contours (isolines) of a scalar function
defined on a triangle mesh surface. Also contains functions for modifying the generated contours.</p>
<dl class="function">
<dt id="bfieldtools.contour.scalar_contour">
<code class="descclassname">bfieldtools.contour.</code><code class="descname">scalar_contour</code><span class="sig-paren">(</span><em>mesh</em>, <em>scalars</em>, <em>N_contours=10</em>, <em>contours=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.scalar_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes contour loops (isolines) for a scalar function defined on a mesh.
The winding direction of the loops is defined according to the rotated gradient of the scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd><p>Trimesh object containing the mesh on which the scalar function is defined</p>
</dd>
<dt><strong>scalars: array-like</strong></dt><dd><p>Vector containing the values of the scalar function at each of the mesh vertices</p>
</dd>
<dt><strong>N_contours: int</strong></dt><dd><p>Number of contours to generate</p>
</dd>
<dt><strong>contours: array-like</strong></dt><dd><p>Optional argument for manual input of contour levels. Overrides <cite>N_contours</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>contour_polys: list</strong></dt><dd><p>list with length <cite>N_contours</cite>. Each list element is anumpy array containing the
coordinats of each polygon vertex.</p>
</dd>
<dt><strong>contour_values: array-like</strong></dt><dd><p>Vector containing the scalar function value for each contour line</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.contour.simplify_contour">
<code class="descclassname">bfieldtools.contour.</code><code class="descname">simplify_contour</code><span class="sig-paren">(</span><em>c</em>, <em>min_edge=0.001</em>, <em>angle_threshold=0.02</em>, <em>smooth=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.simplify_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies contours by merging small (short) segments and
with only a small angle difference.</p>
<p>Optionally applies smoothing to contour shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c: list</strong></dt><dd><p>List of polygons describing closed loops.</p>
</dd>
<dt><strong>min_edge: float</strong></dt><dd><p>Minimum edge length. Edges shorter than this are merged.</p>
</dd>
<dt><strong>angle_threshold: float</strong></dt><dd><p>Minimum angle. Edges with smaller angle differences are merged.</p>
</dd>
<dt><strong>smooth: bool</strong></dt><dd><p>If True, apply smoothing to the polygon shapes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c: list</strong></dt><dd><p>Modified list of polygons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.laplacian_mesh">
<span id="bfieldtools-laplacian-mesh-module"></span><h2>bfieldtools.laplacian_mesh module<a class="headerlink" href="#module-bfieldtools.laplacian_mesh" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing geometric quantities of triangle surface meshes,
such as the Laplacian, mass and gradient matrices.</p>
<dl class="function">
<dt id="bfieldtools.laplacian_mesh.gradient">
<code class="descclassname">bfieldtools.laplacian_mesh.</code><code class="descname">gradient</code><span class="sig-paren">(</span><em>vals</em>, <em>mesh</em>, <em>rotated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.laplacian_mesh.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies mesh (rotated) gradient matrix operator on vector that is
defined in the vertex locations of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vals: Nv x 1 array of scalar data to compute the gradient of</strong></dt><dd></dd>
<dt><strong>mesh: Trimesh object describing the triangular mesh</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradient (3, Ntris)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.laplacian_mesh.gradient_matrix">
<code class="descclassname">bfieldtools.laplacian_mesh.</code><code class="descname">gradient_matrix</code><span class="sig-paren">(</span><em>mesh</em>, <em>rotated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.laplacian_mesh.gradient_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a (rotated) gradient matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Gx ,Gy, Gx (Ntris, Nverts) matrices</strong></dt><dd><p>for calculating the components of gradient at triangles</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.laplacian_mesh.laplacian_matrix">
<code class="descclassname">bfieldtools.laplacian_mesh.</code><code class="descname">laplacian_matrix</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.laplacian_mesh.laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse Laplace(-Beltrami) operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Cotangent weights: w_ij = - 0.5* (cot(alpha) + cot(beta))</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.laplacian_mesh.mass_matrix">
<code class="descclassname">bfieldtools.laplacian_mesh.</code><code class="descname">mass_matrix</code><span class="sig-paren">(</span><em>mesh</em>, <em>da=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.laplacian_mesh.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mass matrix of mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Mesh mass matrix (Nvertices, Nvertices)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.magnetic_field_mesh">
<span id="bfieldtools-magnetic-field-mesh-module"></span><h2>bfieldtools.magnetic_field_mesh module<a class="headerlink" href="#module-bfieldtools.magnetic_field_mesh" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for calculating the coupling of surface current density in a
triangle mesh to magnetic field.</p>
<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.compute_A">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">compute_A</code><span class="sig-paren">(</span><em>mesh</em>, <em>r</em>, <em>Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.compute_A" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential matrices (one for each coordinate)
from linear stream functions using analytic integral</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.compute_C">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">compute_C</code><span class="sig-paren">(</span><em>mesh</em>, <em>r</em>, <em>Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.compute_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C: (Np, Nvertices, 3) array</strong></dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.compute_C_analytic">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">compute_C_analytic</code><span class="sig-paren">(</span><em>mesh</em>, <em>r</em>, <em>Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.compute_C_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing the mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C: (Np, Nvertices, 3) array</strong></dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.compute_C_loops">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">compute_C_loops</code><span class="sig-paren">(</span><em>mesh</em>, <em>r</em>, <em>basis=None</em>, <em>vert_links=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.compute_C_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.
See eq. 5.13 in Michael Poole’s thesis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing mesh</strong></dt><dd></dd>
<dt><strong>r: (Np, 3) array</strong></dt><dd><p>Field evaluation points</p>
</dd>
<dt><strong>basis: dict</strong></dt><dd><p>basis functions used in computation can be given as parameter</p>
</dd>
<dt><strong>vert_links: list of lists</strong></dt><dd><p>Describes the neighborhood for each vertex</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C: (Np, Nvertices, 3) array</strong></dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.compute_U">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">compute_U</code><span class="sig-paren">(</span><em>mesh</em>, <em>r</em>, <em>Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.compute_U" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scalar potential matrix from linear stream functions
using analytic integral</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.create_basis">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">create_basis</code><span class="sig-paren">(</span><em>mesh</em>, <em>centre=array([0</em>, <em>0</em>, <em>0])</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.create_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate “hat” basis functions for each vertex in a given mesh, see Michael Poole’s thesis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>basis: dict</strong></dt><dd><p>dict containing basis functions for each vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.get_neighbour_vertices">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">get_neighbour_vertices</code><span class="sig-paren">(</span><em>vertices</em>, <em>edges</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.get_neighbour_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the neighbor vertex indices for all vertices</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.get_vert_links">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">get_vert_links</code><span class="sig-paren">(</span><em>verts</em>, <em>tris</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.get_vert_links" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the triangles that each vertex corresponds to.</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.make_2D_array">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">make_2D_array</code><span class="sig-paren">(</span><em>lis</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.make_2D_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get 2D array from a list of lists</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.magnetic_field_mesh.make_3D_array">
<code class="descclassname">bfieldtools.magnetic_field_mesh.</code><code class="descname">make_3D_array</code><span class="sig-paren">(</span><em>lis</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.magnetic_field_mesh.make_3D_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get 3D [x, y, 3] array from a list of lists of 3x1 vectors</p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_class">
<span id="bfieldtools-mesh-class-module"></span><h2>bfieldtools.mesh_class module<a class="headerlink" href="#module-bfieldtools.mesh_class" title="Permalink to this headline">¶</a></h2>
<p>Contains a class used for wrapping a mesh (in the form of a Trimesh object) together with
some convinient functions and properties.</p>
<dl class="class">
<dt id="bfieldtools.mesh_class.LazyProperty">
<em class="property">class </em><code class="descclassname">bfieldtools.mesh_class.</code><code class="descname">LazyProperty</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.LazyProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Implementation of lazily loading properties, see
<a class="reference external" href="http://blog.pythonisito.com/2008/08/lazy-descriptors.html">http://blog.pythonisito.com/2008/08/lazy-descriptors.html</a>
On first invocation, a lazy property calls a function that populates
the property (acts as a method). Afterwards, it acts like a normal property.</p>
</dd></dl>

<dl class="class">
<dt id="bfieldtools.mesh_class.MeshWrapper">
<em class="property">class </em><code class="descclassname">bfieldtools.mesh_class.</code><code class="descname">MeshWrapper</code><span class="sig-paren">(</span><em>verts=None</em>, <em>tris=None</em>, <em>mesh_file=None</em>, <em>mesh_obj=None</em>, <em>process=False</em>, <em>fix_normals=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class that is used for surface mesh field calculations, e.g. coil design.
Computation functions are typically external functions that are called
using lazy properties.</p>
<p>The mesh surface can consist of a single contiguous surface or several separate
surfaces within a single mesh object.</p>
<dl class="attribute">
<dt id="bfieldtools.mesh_class.MeshWrapper.inductance">
<code class="descname">inductance</code><em class="property"> = None</em><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.inductance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="bfieldtools.mesh_class.MeshWrapper.laplacian">
<code class="descname">laplacian</code><em class="property"> = None</em><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.laplacian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="bfieldtools.mesh_class.MeshWrapper.mass">
<code class="descname">mass</code><em class="property"> = None</em><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.mass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.MeshWrapper.plot_mesh">
<code class="descname">plot_mesh</code><span class="sig-paren">(</span><em>representation='wireframe'</em>, <em>opacity=0.5</em>, <em>color=(0</em>, <em>0</em>, <em>0)</em>, <em>cull_front=False</em>, <em>cull_back=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.plot_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply plot the mesh surface in mayavi.</p>
</dd></dl>

<dl class="attribute">
<dt id="bfieldtools.mesh_class.MeshWrapper.resistance">
<code class="descname">resistance</code><em class="property"> = None</em><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.resistance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.MeshWrapper.save_pickle">
<code class="descname">save_pickle</code><span class="sig-paren">(</span><em>target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.MeshWrapper.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the MeshWrapper object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_class.load_pickle">
<code class="descclassname">bfieldtools.mesh_class.</code><code class="descname">load_pickle</code><span class="sig-paren">(</span><em>target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load pickled MeshWrapper object from file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to load from</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>obj: loaded MeshWrapper object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_class.save_pickle">
<code class="descclassname">bfieldtools.mesh_class.</code><code class="descname">save_pickle</code><span class="sig-paren">(</span><em>obj</em>, <em>target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the MeshWrapper object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object to save to file</strong></dt><dd></dd>
<dt><strong>target_file: str</strong></dt><dd><p>file name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mutual_inductance_mesh">
<span id="bfieldtools-mutual-inductance-mesh-module"></span><h2>bfieldtools.mutual_inductance_mesh module<a class="headerlink" href="#module-bfieldtools.mutual_inductance_mesh" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing the inductance matrices of triangle surface meshes,
including both self- and mutual-inductance.</p>
<dl class="function">
<dt id="bfieldtools.mutual_inductance_mesh.mutual_inductance_matrix">
<code class="descclassname">bfieldtools.mutual_inductance_mesh.</code><code class="descname">mutual_inductance_matrix</code><span class="sig-paren">(</span><em>mesh1</em>, <em>mesh2</em>, <em>planar=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mutual_inductance_mesh.mutual_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a mutual inductance matrix for hat basis functions
(stream functions) between two surface meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh1: Trimesh mesh object for mesh 1</strong></dt><dd></dd>
<dt><strong>mesh2: Trimesh mesh object for mesh 2</strong></dt><dd></dd>
<dt><strong>planar: boolean</strong></dt><dd><p>If True, use planar assumption when calculating</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>M: (Nvertices1 x Nvertices2) array</strong></dt><dd><p>Mutual inductance matrix between mesh1 and mesh2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mutual_inductance_mesh.mutual_inductance_matrix_from_A">
<code class="descclassname">bfieldtools.mutual_inductance_mesh.</code><code class="descname">mutual_inductance_matrix_from_A</code><span class="sig-paren">(</span><em>mesh1</em>, <em>mesh2</em>, <em>planar=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mutual_inductance_mesh.mutual_inductance_matrix_from_A" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a mutual inductance matrix for hat basis functions
(stream functions) between two surface meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh1: Trimesh mesh object for mesh 1</strong></dt><dd></dd>
<dt><strong>mesh2: Trimesh mesh object for mesh 2</strong></dt><dd></dd>
<dt><strong>planar: boolean</strong></dt><dd><p>If True, use planar assumption when calculating</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>M: (Nvertices1 x Nvertices2) array</strong></dt><dd><p>Mutual inductance matrix between mesh1 and mesh2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mutual_inductance_mesh.self_inductance_matrix">
<code class="descclassname">bfieldtools.mutual_inductance_mesh.</code><code class="descname">self_inductance_matrix</code><span class="sig-paren">(</span><em>mesh</em>, <em>planar=False</em>, <em>Nchunks=1</em>, <em>approx=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mutual_inductance_mesh.self_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a self inductance matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>M: (Nvertices x Nvertices) array</strong></dt><dd><p>Self.inductance matrix of <cite>mesh</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.sphtools">
<span id="bfieldtools-sphtools-module"></span><h2>bfieldtools.sphtools module<a class="headerlink" href="#module-bfieldtools.sphtools" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.sphtools.compute_sphcoeffs_mesh">
<code class="descclassname">bfieldtools.sphtools.</code><code class="descname">compute_sphcoeffs_mesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.compute_sphcoeffs_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes multipole moment (spherical harmonics coefficient) transformation
from the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alm: (lmax*(lmax+2)xNvertices array</strong></dt><dd><p>transformation from the mesh to alm coefficients (r**l-terms)</p>
</dd>
<dt><strong>blm: (lmax*(lmax+2)xNvertices array</strong></dt><dd><p>transformation from the mesh to blm coefficients (r**(-l)-terms)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="bfieldtools.sphtools.plotsph">
<em class="property">class </em><code class="descclassname">bfieldtools.sphtools.</code><code class="descname">plotsph</code><a class="headerlink" href="#bfieldtools.sphtools.plotsph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for visualization of spherical harmonics and basis vector functions.</p>
<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotBPhilm_volume">
<code class="descname">plotBPhilm_volume</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>lim</em>, <em>Np</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotBPhilm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Philm’ (r**(-l)) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Philm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj: mayavi object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotBPsilm_volume">
<code class="descname">plotBPsilm_volume</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>lim</em>, <em>Np</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotBPsilm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Psilm’ (r**l) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Psilm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj: mayavi object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotPhilm">
<code class="descname">plotPhilm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotPhilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Philm’ (r**(-l)) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj: mayavi object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotPsilm">
<code class="descname">plotPsilm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotPsilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Psilm’ (r**l) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj: mayavi object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotYlm">
<code class="descname">plotYlm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotYlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics of order m and degree l.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.plotsph.plotYlms">
<code class="descname">plotYlms</code><span class="sig-paren">(</span><em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotsph.plotYlms" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics up to lmax.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="bfieldtools.sphtools.sphbasis">
<em class="property">class </em><code class="descclassname">bfieldtools.sphtools.</code><code class="descname">sphbasis</code><span class="sig-paren">(</span><em>Np</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for constructing spherical harmonics (Ylms), their gradients
and related magnetic field ‘basis vectorfunctions’
(Psilms for r**l components, Philms for r**(-l) components).</p>
<p>Uses notations and definitions by Plattner and Simons (2014; <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>)
and the same normalization conventions.</p>
<p>Integration over a surface of unit sphere is
used as the inner product &lt;C,D&gt; = int C dot D dOmega.</p>
<p>Has also lot of functions for spherical &lt;-&gt; cartesian transformations.</p>
<p>TODO: mu0 might be missing!!!</p>
<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.Blm">
<code class="descname">Blm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.Blm" title="Permalink to this definition">¶</a></dt>
<dd><p>Blm vector function (see Eq. 19 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Blm: Nx3 array</strong></dt><dd><p>Blm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.Philm">
<code class="descname">Philm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.Philm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Philm) for r**(-l) component of the magnetic field.
Normalization &lt;Philm,Phikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Philm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Philm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Philm: Nx3 array</strong></dt><dd><p>Philm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.Plm">
<code class="descname">Plm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.Plm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plm vector function (see Eq. 18 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Plm: Nx3 array</strong></dt><dd><p>Plm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.Psilm">
<code class="descname">Psilm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.Psilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Psilm) for r**l component of the magnetic field.
Normalization &lt;Psilm,Psikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Psilm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Psilm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Psilm: Nx3 array</strong></dt><dd><p>Psilm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.Rotmatrix">
<code class="descname">Rotmatrix</code><span class="sig-paren">(</span><em>sp</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.Rotmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs rotation matrix from cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vmat: 3x3 array</strong></dt><dd><p>rotation matrix from cartesian to spherical.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.avsphspectra">
<code class="descname">avsphspectra</code><span class="sig-paren">(</span><em>fun</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.avsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**l-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coeffs: lmax*(lmax+2)x1 arrays</strong></dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.basis_fields">
<code class="descname">basis_fields</code><span class="sig-paren">(</span><em>p</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.basis_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic fields for each sph coefficient.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>field: Nx3 array</strong></dt><dd><p>magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.bvsphspectra">
<code class="descname">bvsphspectra</code><span class="sig-paren">(</span><em>fun</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.bvsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**(-l)-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coeffs: lmax*(lmax+2)x1 arrays</strong></dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.cartesian2spherical">
<code class="descname">cartesian2spherical</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.cartesian2spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>cartesian coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.cartvec2sph">
<code class="descname">cartvec2sph</code><span class="sig-paren">(</span><em>sp</em>, <em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.cartvec2sph" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>svec: Nx3 array</strong></dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.derlpmn_em">
<code class="descname">derlpmn_em</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.derlpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes derivative of associated Legendre function (Plm) of the first kind of order m and degree l
with respect to the argument x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>derlp: Nx1 array</strong></dt><dd><p>dPlm/dx at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.derxlm">
<code class="descname">derxlm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.derxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Xlm with respect to theta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>derxlm: Nx1 array</strong></dt><dd><p>dXlm/dtheta at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.dphiylm">
<code class="descname">dphiylm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.dphiylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to phi dYlm/dphi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dphiylm: Nx1 array</strong></dt><dd><p>dYlm/dphi at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.dthylm">
<code class="descname">dthylm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.dthylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to theta dYlm/dtheta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dthylm: Nx1 array</strong></dt><dd><p>dYlm/dtheta at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.field">
<code class="descname">field</code><span class="sig-paren">(</span><em>p</em>, <em>acoeffs</em>, <em>bcoeffs</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.field" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic field from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>field: Nx3 array</strong></dt><dd><p>magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.initqp">
<code class="descname">initqp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.initqp" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises quadrature points on the sphere.</p>
<p>Default points are McLaren(10) so that we avoid singularities.</p>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.innerproduct">
<code class="descname">innerproduct</code><span class="sig-paren">(</span><em>fun1</em>, <em>fun2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.innerproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of vector functions fun1 and fun2.
Defined as integration over a surface of unit sphere &lt;C,D&gt; = int C dot D dOmega.
Quadrature rule defined in qp is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun1: Nx3 array</strong></dt><dd><p>vector function 1</p>
</dd>
<dt><strong>fun2: Nx3 array</strong></dt><dd><p>vector function 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dotp: int</strong></dt><dd><p>inner product of fun1 and fun2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.lpmn_em">
<code class="descname">lpmn_em</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.lpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes associated Legendre function (Plm) of the first kind of order m and degree l.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lp: Nx1 array</strong></dt><dd><p>Plm at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.potential">
<code class="descname">potential</code><span class="sig-paren">(</span><em>p</em>, <em>acoeffs</em>, <em>bcoeffs</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic scalar potential from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the potential is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pot: Nx1 array</strong></dt><dd><p>magnetic scalar potential at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.sinxlm">
<code class="descname">sinxlm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.sinxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes m/(sin(theta))*Xlm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sinxlm: Nx1 array</strong></dt><dd><p>m/(sin(theta))*Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.spherical2cartesian">
<code class="descname">spherical2cartesian</code><span class="sig-paren">(</span><em>sp</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.spherical2cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps spherical coordinates to cartesian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>cartesian croodinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.sphvec2cart">
<code class="descname">sphvec2cart</code><span class="sig-paren">(</span><em>sp</em>, <em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.sphvec2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>svec: Nx3 array</strong></dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.xlm">
<code class="descname">xlm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.xlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Xlm-function used in the definition of spherical harmonics (Ylm).
Follows notation of Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Xlm: Nx1 array</strong></dt><dd><p>Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.ylm">
<code class="descname">ylm</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.ylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Real spherical harmonics as defined by Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Ylm: Nx1 array</strong></dt><dd><p>Ylm at (theta,phi)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="bfieldtools.sphtools.sphfittools">
<em class="property">class </em><code class="descclassname">bfieldtools.sphtools.</code><code class="descname">sphfittools</code><a class="headerlink" href="#bfieldtools.sphtools.sphfittools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for fitting spherical harmonics basis functions to measured magnetic field data.
Can be used to calculate the l,m-spectra of measured data and reconstructing field with
the spherical harmonics representation.</p>
<dl class="method">
<dt id="bfieldtools.sphtools.sphfittools.fitSpectra">
<code class="descname">fitSpectra</code><span class="sig-paren">(</span><em>coords</em>, <em>Bmeas</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphfittools.fitSpectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits spherical harmonics representation (r**l) to measured data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>coords: Nx3x3 array</strong></dt><dd><p>measurement coordinates, each measured field direction
in the third dimension: e.g. coords[:,:,2] gives the coordinates of measured z-components.</p>
</dd>
<dt><strong>Bmeas: Nx3 array</strong></dt><dd><p>the measured field values along different directions (x,y,z)</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the fit is done</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>the unnormalized coefficients</p>
</dd>
<dt><strong>coeffs2: lmax*(lmax+2)x1 array</strong></dt><dd><p>the ‘properly’ normalized squared coefficients</p>
</dd>
<dt><strong>nrmse: float</strong></dt><dd><p>normalized rms error in percents between the data and fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphfittools.reconstructB">
<code class="descname">reconstructB</code><span class="sig-paren">(</span><em>p</em>, <em>coeffs</em>, <em>lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphfittools.reconstructB" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs the magnetic field using the spherical harmonics coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates where B is reconstructed</p>
</dd>
<dt><strong>coeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>the unnormalized l,m-coefficients</p>
</dd>
<dt><strong>lmax:int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B: Nx3 array</strong></dt><dd><p>reconstructed magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-bfieldtools.thermal_noise">
<span id="bfieldtools-thermal-noise-module"></span><h2>bfieldtools.thermal_noise module<a class="headerlink" href="#module-bfieldtools.thermal_noise" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing thermal noise in conductive thin objects.</p>
<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_ac_Bnoise">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">compute_ac_Bnoise</code><span class="sig-paren">(</span><em>mesh</em>, <em>vl</em>, <em>fp</em>, <em>freqs</em>, <em>sigma</em>, <em>d</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_ac_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the AC magnetic noise due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B: Nfrequencies x Nfieldpoints x 3components array</strong></dt><dd><p>magnetic RMS noise across frequencies</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_current_modes">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">compute_current_modes</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eddy-current modes for a mesh using surface laplacian.
Uses Dirichlet boundary condition, i.e., stream function is zero at boundary:
no current flow outside the surface.
The modes are normalized so that the squared norm of the stream function gradient
integrates to 1 over the surface. With this normalization, the resistances
of the current modes are R_k = 1/(sigma*d), sigma = conductivity, d = thickness.
See Zevenhoven et al. (2014).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">compute_dc_Bnoise</code><span class="sig-paren">(</span><em>mesh</em>, <em>vl</em>, <em>fp</em>, <em>sigma</em>, <em>d</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B: Nfieldpoints x 3components array</strong></dt><dd><p>magnetic RMS noise at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise_covar">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">compute_dc_Bnoise_covar</code><span class="sig-paren">(</span><em>mesh</em>, <em>vl</em>, <em>fp</em>, <em>sigma</em>, <em>d</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise covariance at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>B: Nfieldpoints x Nfieldpoints x 3components array</strong></dt><dd><p>magnetic noise covariance at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.integrate_Bnoise_covar">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">integrate_Bnoise_covar</code><span class="sig-paren">(</span><em>B_covar</em>, <em>weighting=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.integrate_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the (quadrature) integrated noise over a volume spanned by the points in fp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B_covar: (N_p, N_p, 3) array</strong></dt><dd><p>One vector component of the covariance matrix computed by compute_dc_Bnoise_covar</p>
</dd>
<dt><strong>weighting: (N_p,) array</strong></dt><dd><p>Weighting factors for each point in the volume. If None (default), use equal weighting.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Bnoise_integrated: float</strong></dt><dd><p>Integrated noise amplitude over the volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.visualize_current_modes">
<code class="descclassname">bfieldtools.thermal_noise.</code><code class="descname">visualize_current_modes</code><span class="sig-paren">(</span><em>mesh</em>, <em>vl</em>, <em>Nmodes</em>, <em>scale</em>, <em>contours=True</em>, <em>colormap='bwr'</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.visualize_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualizes current modes up to Nmodes.
TODO: make this more flexible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>Nmodes: int</strong></dt><dd><p>Number of modes to be plotted</p>
</dd>
<dt><strong>scale: float</strong></dt><dd><p>Scaling factor</p>
</dd>
<dt><strong>contours: boolean</strong></dt><dd><p>If True, show contours</p>
</dd>
<dt><strong>colormap: string</strong></dt><dd><p>Which (matplotlib) colormap to use</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.utils">
<span id="bfieldtools-utils-module"></span><h2>bfieldtools.utils module<a class="headerlink" href="#module-bfieldtools.utils" title="Permalink to this headline">¶</a></h2>
<p>This module contains miscellaneous utility functions used across bfieldtools.</p>
<dl class="attribute">
<dt id="bfieldtools.utils.assemble_matrix">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">assemble_matrix</code><a class="headerlink" href="#bfieldtools.utils.assemble_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="attribute">
<dt id="bfieldtools.utils.assemble_matrix2">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">assemble_matrix2</code><a class="headerlink" href="#bfieldtools.utils.assemble_matrix2" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data for separate meshes 1 and 2</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="attribute">
<dt id="bfieldtools.utils.assemble_matrix_chunk">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">assemble_matrix_chunk</code><a class="headerlink" href="#bfieldtools.utils.assemble_matrix_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data. Version for computation in which eval points
are chunked smaller, less memory-intensive parts</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.cylinder_points">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">cylinder_points</code><span class="sig-paren">(</span><em>radius=1</em>, <em>length=1</em>, <em>nlength=10</em>, <em>alpha=360</em>, <em>nalpha=10</em>, <em>center=array([0</em>, <em>0</em>, <em>0])</em>, <em>orientation=array([1</em>, <em>0</em>, <em>0])</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.cylinder_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return a set of points on a cylindrical surface.</p>
</dd></dl>

<dl class="attribute">
<dt id="bfieldtools.utils.dual_areas">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">dual_areas</code><a class="headerlink" href="#bfieldtools.utils.dual_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (dual) areas for each node in inds</p>
<p>Dual area == area summed over the neighbouring triangles divided by 3</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.fibonacci_sphere">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">fibonacci_sphere</code><span class="sig-paren">(</span><em>samples=10</em>, <em>center=array([0</em>, <em>0</em>, <em>0])</em>, <em>radius=1</em>, <em>randomize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.fibonacci_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a set of points approximately evenly distributed on a sphere,
with adjustable center and radius. Uses spherical Fibonacci Lattice.</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.find_mesh_boundaries">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">find_mesh_boundaries</code><span class="sig-paren">(</span><em>verts</em>, <em>tris</em>, <em>edges</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.find_mesh_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the open boundaries of a mesh by finding the edges that only
belong to a single triangle. Returns an index array of inner vertices
and triangles that do not touch the outer boundary.
Takes edge parameter for convenience.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts</strong></dt><dd></dd>
<dt><strong>tris</strong></dt><dd></dd>
<dt><strong>edges</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>boundary_verts</strong></dt><dd></dd>
<dt><strong>inner_verts</strong></dt><dd></dd>
<dt><strong>boundary_tris</strong></dt><dd></dd>
<dt><strong>inner_tris</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.fix_normals">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">fix_normals</code><span class="sig-paren">(</span><em>mesh</em>, <em>origin=array([0</em>, <em>0</em>, <em>0])</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to fix face windings and normals such that normals are always “pointing out”
from the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>origin: array-like (3, )</strong></dt><dd><p>Specified from where the normals should “point out”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh: modified Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.get_quad_points">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">get_quad_points</code><span class="sig-paren">(</span><em>verts</em>, <em>tris</em>, <em>method='sevenpoint'</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.get_quad_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get quad points and weights from quadrature rules implemented in
quadpy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts: array-like [Nverts x 3]</strong></dt><dd></dd>
<dt><strong>tris: array-like [Ntris x 3]</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w: array-like  (Nquad, )</strong></dt><dd><p>quadrature weights</p>
</dd>
<dt><strong>qp: array-like (Ntris, Nquad)</strong></dt><dd><p>quadrature points in each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.tri_normals_and_areas">
<code class="descclassname">bfieldtools.utils.</code><code class="descname">tri_normals_and_areas</code><span class="sig-paren">(</span><em>r</em>, <em>tri</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.tri_normals_and_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get triangle normals and areas from vertices (r) and
triangle indices (tri)</p>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019, bfieldtools developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>