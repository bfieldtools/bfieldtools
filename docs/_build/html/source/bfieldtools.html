<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>bfieldtools package &#8212; bfieldtools 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="API Reference" href="modules.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/logo_simple.png"></span>
          bfieldtools</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../overview.html">Overview</a></li>
                <li><a href="../installation.html">Installation</a></li>
                <li><a href="../literature.html">Literature</a></li>
                <li><a href="../auto_examples/index.html">Example gallery</a></li>
                <li><a href="modules.html">API Reference</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../literature.html">Literature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Example gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#coil-design">Coil design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#software-publication-examples">Software publication examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#thermal-noise-computation">Thermal noise computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#validation">Validation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Reference</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="bfieldtools-package">
<h1>bfieldtools package<a class="headerlink" href="#bfieldtools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bfieldtools.line_magnetics">
<span id="bfieldtools-line-magnetics-module"></span><h2>bfieldtools.line_magnetics module<a class="headerlink" href="#module-bfieldtools.line_magnetics" title="Permalink to this headline">¶</a></h2>
<p>Functions for working with current polylines</p>
<dl class="py function">
<dt id="bfieldtools.line_magnetics.cross">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">cross</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r1</span></em>, <em class="sig-param"><span class="n">r2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross product without overhead</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.line_magnetics.flux">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">loops</span></em>, <em class="sig-param"><span class="n">vertices_other</span></em>, <em class="sig-param"><span class="n">Nquad</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute magnetic flux created by a segmented line current loops
(vertices, loops) on a another closed loop of segmented current
(vertices_other). The other loop is numerically integrated.</p>
<p>In other words, calculate mutual inductance of the current loops.</p>
<p><strong>NOT SUITABLE</strong> for calculating the self-flux, i.e., self-inductance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices:</strong></dt><dd><p>all vertices in segmented loops generating the flux</p>
</dd>
<dt><strong>loops:</strong></dt><dd><p>list of indices defining closed loops of vertices, if
None use all vertices. All loops must have the same
number of indices (this could be changed in future)
Example: Giving array of 4 vertices, the loops can be
defined as loops = np.array([[0,1,2,3]])</p>
</dd>
<dt><strong>vertices_other:</strong></dt><dd><p>vertices in the loop receiving the flux</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>flux in the other loop generated by loops (Nloops,)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.line_magnetics.magnetic_field">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">magnetic_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.magnetic_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute B-field of a segmented line current.
This calculation is based on
Introduction to Electrodynamics (3rd Edition)
by Griffiths (page 217)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points:   (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bfield: (N_points, 3) array</dt><dd><p>Magnetic field at evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.line_magnetics.magnetic_field2">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">magnetic_field2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.magnetic_field2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute B-field of a segmented line current.
See: Compact expressions for the Biot–Savart fields of a filamentary segments
by Hanson &amp; Hirshman: <a class="reference external" href="https://doi.org/10.1063/1.1507589">https://doi.org/10.1063/1.1507589</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points:   (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bfield: (N_points, 3) array</dt><dd><p>Magnetic field at evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.line_magnetics.scalar_potential">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">scalar_potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.scalar_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the scalar magnetic potential of a segmented current loop at given points.
This is equal to the solid angle spanned by the loop (polygon), times a constant.
The first and last vertices are connected to close the loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U: array (Npoints, )</dt><dd><p>Scalar magnetic potential</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.line_magnetics.vector_potential">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">vector_potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">1e-12</span></em>, <em class="sig-param"><span class="n">symmetrize</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.vector_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential of a segmented line currents.
Based on straightforward integration of 1/r potential over a line
i.e. the gamma0 integral</p>
<p>See: Compact expressions for the Biot–Savart fields of a filamentary segments
by Hanson &amp; Hirshman: <a class="reference external" href="https://doi.org/10.1063/1.1507589">https://doi.org/10.1063/1.1507589</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A: array (Npoints, 3)</dt><dd><p>Vector potential</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.coil_optimize">
<span id="bfieldtools-coil-optimize-module"></span><h2>bfieldtools.coil_optimize module<a class="headerlink" href="#module-bfieldtools.coil_optimize" title="Permalink to this headline">¶</a></h2>
<p>Includes files for coil optimization (stream function optimization)
using either a numerical solver or regularized least squares</p>
<dl class="py function">
<dt id="bfieldtools.coil_optimize.cvxopt_solve_qp">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">cvxopt_solve_qp</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">q</em>, <em class="sig-param">G=None</em>, <em class="sig-param">h=None</em>, <em class="sig-param">A=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">tolerance=1e-07</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxopt_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use cvxopt (without CVXPY wrapper) to minimize</p>
<div class="math notranslate nohighlight">
\[(1/2) \mathbf{x}^T  \mathbf{P}  \mathbf{x} + \mathbf{q}^T \mathbf{x}\]</div>
<p>subject to</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} \mathbf{x} \leq \mathbf{h}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\mathbf{A} \mathbf{x} = \mathbf{b}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P: (N_x, N_x) array</strong></dt><dd><p>Quadratic minimization matrix</p>
</dd>
<dt><strong>q: (N_x, ) array</strong></dt><dd><p>Linear penalty term vector</p>
</dd>
<dt><strong>G: (N_h, N_x) array</strong></dt><dd><p>Linear inequality matrix</p>
</dd>
<dt><strong>h: (N_h, ) array</strong></dt><dd><p>Linear inequality constraint vector</p>
</dd>
<dt><strong>A: (N_b, N_x) array</strong></dt><dd><p>Linear equality matrix</p>
</dd>
<dt><strong>b: (N_b, ) array</strong></dt><dd><p>Linear equality constraint vector</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Use to pass cvxopt solver options, such as tolerance</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>x: (N_x, ) array</dt><dd><p>Optimized solution for x (if available)</p>
</dd>
<dt>sol: CVXOPT solution</dt><dd><p>Solution object with optimization info</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.coil_optimize.cvxpy_solve_qp">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">cvxpy_solve_qp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">P</span></em>, <em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">'MOSEK'</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxpy_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bare-bones quadratic programming solver function for CVXPY, minimizes</p>
<div class="math notranslate nohighlight">
\[(1/2) \mathbf{x}^T  \mathbf{P}  \mathbf{x}\]</div>
<p>subject to</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} \mathbf{x} \leq \mathbf{h}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P: (N_x, N_x) array</strong></dt><dd><p>Quadratic minimization matrix</p>
</dd>
<dt><strong>G: (N_h, N_x) array</strong></dt><dd><p>Linear inequality matrix</p>
</dd>
<dt><strong>h: (N_h, ) array</strong></dt><dd><p>Linear inequality constraint vector</p>
</dd>
<dt><strong>solver: string or cvxpy solver</strong></dt><dd><p>solver to use in CVXPY, can be passed as string or directly</p>
</dd>
<dt><strong>tolerance: float or None (default)</strong></dt><dd><p>Override default tolerance values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>x.value: (N_x, ) array</dt><dd><p>Optimized solution for x (if available)</p>
</dd>
<dt>prob: CVXPY problem</dt><dd><p>Problem object with optimization info</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.coil_optimize.optimize_lsq">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">optimize_lsq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conductor</span></em>, <em class="sig-param"><span class="n">bfield_specification</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">1000.0</span></em>, <em class="sig-param"><span class="n">objective</span><span class="o">=</span><span class="default_value">'minimum_inductive_energy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.optimize_lsq" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>conductor: Conductor object</strong></dt><dd><p>Contains Trimesh mesh as well as physical properties, e.g. inductance</p>
</dd>
<dt><strong>bfield_specification: list</strong></dt><dd><p>List in which element is a dictionary containing a coil specification.</p>
</dd>
<dt><strong>objective: string or dict</strong></dt><dd><p>if string, either <em>‘minimum_inductive_energy’</em> or <em>‘minimum_ohmic_power’</em>
if tuple, should contain: (a, b), where a and b are floats describing the
inductive and resitive weighting factors.
The resistance matrix is scaled according to the largest singular value
of the inductance matrix for consistent behavior across meshes.</p>
</dd>
<dt><strong>reg: float</strong></dt><dd><p>Regularization/tradeoff parameter (lambda). A larger lambda leads to
more emphasis on the specification, at the cost of the quadratic objective.
The lambda value is relative to the maximum singular value w
of the eigenvalue equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{C}^T \mathbf{C}  \mathbf{v}[:,i] = \mathbf{w}[i]  \mathbf{Q} \mathbf{v}[:,i]\]</div>
<p>where C is the constraint matrix and Q is the quadratic objective matrix.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>S: StreamFunction</strong></dt><dd><p>Optimization solution</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Each specification is a dict, which contains</dt><dd><ul class="simple">
<li><p>coupling: Coupling matrix (N_r, N_verts, 3)</p></li>
<li><p>target: (N_r, 3)</p></li>
</ul>
</dd>
<dt><strong>NOTE</strong> The following spec parameters are ignored:</dt><dd><ul class="simple">
<li><p>abs_error: float or (N_r, 3)</p></li>
<li><p>rel_error: float or (N_r, 3)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.coil_optimize.optimize_streamfunctions">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">optimize_streamfunctions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conductor</span></em>, <em class="sig-param"><span class="n">bfield_specification</span></em>, <em class="sig-param"><span class="n">objective</span><span class="o">=</span><span class="default_value">'minimum_inductive_energy'</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_opts</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">problem</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.optimize_streamfunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic optimization of coil stream function according to a specified objective,
while keeping specified target field at target points within given constraints.</p>
<p>Utilizes CVXPY and a numerical iterative solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>conductor: Conductor object</strong></dt><dd><p>Contains Trimesh mesh as well as physical properties, e.g. inductance</p>
</dd>
<dt><strong>bfield_specification: list</strong></dt><dd><p>List in which element is a dictionary containing a coil specification.
See notes for specification syntax.</p>
</dd>
<dt><strong>objective: string or dict</strong></dt><dd><p>if string, either <em>‘minimum_inductive_energy’</em> or <em>‘minimum_ohmic_power’</em>
if tuple, should contain: (a, b), where a and b are floats describing the
inductive and resitive weighting factors.
The resistance matrix is scaled according to the largest singular value
of the inductance matrix for consistent behavior across meshes.</p>
</dd>
<dt><strong>solver: string</strong></dt><dd><p>string specifying which solver CVXPY will use</p>
</dd>
<dt><strong>solver_opt: dict</strong></dt><dd><p>dict containing solver options CVXPY will pass to the solver</p>
</dd>
<dt><strong>problem: CVXPY problem object</strong></dt><dd><p>If passed, will use already existing problem (<strong>MUST BE SAME DIMENSIONS</strong>) to
skip DCP processing/reformulation time.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>s: vector</dt><dd><p>Vector with length len(<cite>conductor.mesh.vertices</cite>), containing the
optimized current density values at each mesh vertex</p>
</dd>
<dt>prob: CVXPY problem object</dt><dd><p>CVXPY problem object containing data, formulation, solution, metric etc</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Each specification is a dict, which contains</dt><dd><ul class="simple">
<li><p>coupling: Coupling matrix (N_r, N_verts, 3)</p></li>
<li><p>target: (N_r, 3)</p></li>
<li><p>abs_error: float or (N_r, 3)</p></li>
<li><p>rel_error: float or (N_r, 3)</p></li>
</ul>
</dd>
</dl>
<p>Either abs_error, rel_error or both must be present.</p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.contour">
<span id="bfieldtools-contour-module"></span><h2>bfieldtools.contour module<a class="headerlink" href="#module-bfieldtools.contour" title="Permalink to this headline">¶</a></h2>
<p>This module includes functions for creating contours (isolines) of a scalar function
defined on a triangle mesh surface. Also contains functions for modifying the generated contours.</p>
<dl class="py function">
<dt id="bfieldtools.contour.scalar_contour">
<code class="sig-prename descclassname">bfieldtools.contour.</code><code class="sig-name descname">scalar_contour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">scalars</span></em>, <em class="sig-param"><span class="n">N_contours</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">contours</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_values</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.scalar_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes contour loops (isolines) for a scalar function defined on a mesh.
The winding direction of the loops is defined according to the rotated gradient of the scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd><p>Trimesh object containing the mesh on which the scalar function is defined</p>
</dd>
<dt><strong>scalars: array-like or StreamFunction</strong></dt><dd><p>Vector containing the values of the scalar function at each of the mesh vertices.
If StreamFunction, uses the vertex-wise values</p>
</dd>
<dt><strong>N_contours: int</strong></dt><dd><p>Number of contours to generate</p>
</dd>
<dt><strong>contours: array-like</strong></dt><dd><p>Optional argument for manual input of contour levels. Overrides <cite>N_contours</cite></p>
</dd>
<dt><strong>return_values: Boolean</strong></dt><dd><p>If True, also return contour values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>contour_polys: list</dt><dd><p>list with length <cite>N_contours</cite>. Each list element is anumpy array containing the
coordinats of each polygon vertex.</p>
</dd>
<dt>contour_values: array-like</dt><dd><p>Vector containing the scalar function value for each contour line,
returned if return_values is True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.contour.simplify_contour">
<code class="sig-prename descclassname">bfieldtools.contour.</code><code class="sig-name descname">simplify_contour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">min_edge</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">angle_threshold</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">smooth</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.simplify_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies contours by merging small (short) segments and
with only a small angle difference.</p>
<p>Optionally applies smoothing to contour shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c: list</strong></dt><dd><p>List of polygons describing closed loops.</p>
</dd>
<dt><strong>min_edge: float</strong></dt><dd><p>Minimum edge length. Edges shorter than this are merged.</p>
</dd>
<dt><strong>angle_threshold: float</strong></dt><dd><p>Minimum angle. Edges with smaller angle differences are merged.</p>
</dd>
<dt><strong>smooth: bool</strong></dt><dd><p>If True, apply smoothing to the polygon shapes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>c: list</dt><dd><p>Modified list of polygons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_calculus">
<span id="bfieldtools-mesh-calculus-module"></span><h2>bfieldtools.mesh_calculus module<a class="headerlink" href="#module-bfieldtools.mesh_calculus" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing vector calculus quantities on triangle surface meshes.
These include the gradient, rotated gradient, divergence, curl, Laplacian and mass matrices.</p>
<dl class="py function">
<dt id="bfieldtools.mesh_calculus.curl">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">curl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vecs</span></em>, <em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.curl" title="Permalink to this definition">¶</a></dt>
<dd><p>Curl applied to tangential vector field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray (Nverts,)</dt><dd><p>Curl applied on the vector field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.curl_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">curl_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.curl_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint curl of tangential vector field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>3 sparse csc_matrices</dt><dd><p>Cx ,Cy, Cz (Nverts, Ntri) matrices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.divergence">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">divergence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vecs</span></em>, <em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Divergence mapping applied to tangential vector field ‘vecs’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vecs: ndarray (3, Nfaces)</strong></dt><dd><p>vector field at mesh faces</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray (Nverts,)</dt><dd><p>Divergence applied on the vector field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.divergence_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">divergence_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.divergence_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Divergence of tangential vector field on mesh faces as a linear mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>3 sparse csc_matrices</dt><dd><p>Dx ,Dy, Dz (Nverts, Ntri) matrices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.gradient">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vals</span></em>, <em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">rotated</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies mesh (rotated) gradient matrix operator on vector that is
defined in the vertex locations of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vals: Nv x 1 array of scalar data to compute the gradient of</strong></dt><dd></dd>
<dt><strong>mesh: Trimesh object describing the triangular mesh</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees clockwise</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray (3, Ntris)</dt><dd><p>surface gradient of vals on each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.gradient_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">gradient_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">rotated</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.gradient_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a (rotated) gradient matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees clockwise</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>3 sparse csr_matrices</dt><dd></dd>
<dt>Gx ,Gy, Gx (Ntris, Nverts) matrices</dt><dd><p>for calculating the components of gradient at triangles</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.laplacian_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">laplacian_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">material_param</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inner_vertices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">holes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse Laplace-Beltrami operator</p>
<p>If inner vertices are not given Laplacian for all the mesh vertices is returned.
This corresponds to zero-Neumann (natural) boundary condition on the possible
outer boundary.
shape==(len(mesh.vertices), len(mesh.vertices))</p>
<p>If inner_vertices but no holes are given, the outer boundary is assumed grounded
and Laplacian only for the inner vertices is returned
shape==(len(inner_vertices), len(inner_vertices))</p>
<p>If both inner_vertices and holes are given, the outer boundary is assumed grounded
and constant floating boundary condition for each hole is assumed
shape==(len(inner_vertices)+len(holes), len(inner_vertices)+len(holes))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
<dt><strong>material_param: array-like with length N_triangles</strong></dt><dd><p>material parameter for each triangle</p>
</dd>
<dt><strong>inner_vertices: list (default None)</strong></dt><dd><p>contains mesh vertex indices corresponding to inner holes</p>
</dd>
<dt><strong>holes: list with length N_holes (default None)</strong></dt><dd><p>each list element contains array-like of mesh vertex indices corresponding to each
mesh hole</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sparse csr_matrix of variable shape (see description)</dt><dd><p>cotangent-laplacian: w_ij = - 0.5* (cot(alpha) + cot(beta))</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_calculus.mass_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">mass_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">lumped</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">inner_vertices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">holes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mass matrix of mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
<dt><strong>lumped: Boolean</strong></dt><dd><p>If True, use lumped approximation of mass matrix. If False (default),
compute exact matrix. See Reuter et al 2009, page 3 (DOI: 10.1016/j.cag.2009.03.005)</p>
</dd>
<dt><strong>inner_vertices: list (default None)</strong></dt><dd><p>contains mesh vertex indices corresponding to inner holes</p>
</dd>
<dt><strong>holes: list with length N_holes (default None)</strong></dt><dd><p>each list element contains array-like of mesh vertex indices corresponding to each
mesh hole</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sparse csr_matrix of variable shape (see the description of laplacian_matrix)</dt><dd><p>Mass matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_magnetics">
<span id="bfieldtools-mesh-magnetics-module"></span><h2>bfieldtools.mesh_magnetics module<a class="headerlink" href="#module-bfieldtools.mesh_magnetics" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for calculating the coupling of surface current density in a
triangle mesh to magnetic field as well as scalar and vector potentials.</p>
<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.get_chunks">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">get_chunks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span></em>, <em class="sig-param"><span class="n">clusters</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.get_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Chunk points in ‘r’ to Nchunks</p>
<p>r : ndarray (Npoints, 3)</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quad_degree</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">analytic</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Given ‘mesh’, computes the “C matrix” which gives the magnetic field at
target points ‘r’ due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>mesh describing the geometry of the field source</p>
</dd>
<dt><strong>r: ndarray (Np, 3)</strong></dt><dd><p>evalution points</p>
</dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use.</p>
</dd>
<dt><strong>analytic: boolean</strong></dt><dd><p>compute field using analytic formula (True) or quadrature (False)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: ndarray (Np, 3, Nvertices)</dt><dd><p>Coupling matrix corresponding to a mapping from a stream function
on the mesh to B-field at the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling_analytic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh
using analytic formulas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>mesh describing the geometry of the field source</p>
</dd>
<dt><strong>r: ndarray (Np, 3)</strong></dt><dd><p>evaluation points</p>
</dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>number of chunks used in the calculation for saving memory</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: ndarray (Np, 3, Nvertices)</dt><dd><p>Coupling matrix corresponding to a mapping from a stream function
on the mesh to B-field at the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic_old">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling_analytic_old</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic_old" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED
Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>mesh describing the geometry of the field source</p>
</dd>
<dt><strong>r: ndarray (Np, 3)</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: ndarray (Np, 3, Nvertices)</dt><dd><p>Coupling matrix corresponding to a mapping from a stream function
on the mesh to B-field at the evaluation points</p>
</dd>
<dt>DEPRECATED</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.scalar_potential_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">scalar_potential_coupling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">multiply_coeff</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">approx_far</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">margin</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.scalar_potential_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling matrix corresponding to a mapping from a stream function
to scalar potential using analytic integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>mesh describing the geometry of the field source</p>
</dd>
<dt><strong>r: ndarray (Np, 3)</strong></dt><dd><p>evaluation points</p>
</dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>number of chunks used in the calculation for saving memory</p>
</dd>
<dt><strong>multiply_coeff: boolean</strong></dt><dd><p>If True, multiply result by mu_0/(4*pi)</p>
</dd>
<dt><strong>approx_far: boolean,</strong></dt><dd><p>approximate the potential using simple quadrature
(see integrals.potential_dipoles) for points far from the source triangles</p>
</dd>
<dt><strong>margin: float</strong></dt><dd><p>cut-off distance for “far” points measured in mean triangle side length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U: ndarray (Np, Nvertices)</dt><dd><p>Coupling matrix corresponding to a mapping from a stream function
on the mesh to scalar potential at the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_magnetics.vector_potential_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">vector_potential_coupling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">approx_far</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">margin</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">chunk_clusters</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.vector_potential_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential coupling matrices
from linear stream functions using analytic integral</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>mesh describing the geometry of the field source</p>
</dd>
<dt><strong>r: ndarray (Np, 3)</strong></dt><dd><p>evaluation points</p>
</dd>
<dt><strong>approx_far: Boolean (True)</strong></dt><dd><p>If True, use approximate calculation for triangles that
far from the source triangles using a simple quadrature
(see integrals.triangle_potential_approx)</p>
</dd>
<dt><strong>margin: float</strong></dt><dd><p>Cut-off distance for “far” points measured in mean triangle side length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A: ndarray (Np, 3, Nvertices)</dt><dd><p>Coupling matrix corresponding to a mapping from a stream function
on the mesh to vector potential at the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.conductor">
<span id="bfieldtools-conductor-module"></span><h2>bfieldtools.conductor module<a class="headerlink" href="#module-bfieldtools.conductor" title="Permalink to this headline">¶</a></h2>
<p>Contains a class used for wrapping a mesh (in the form of a Trimesh object) together with
some convenient functions and properties.</p>
<dl class="py class">
<dt id="bfieldtools.conductor.Conductor">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">Conductor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tris</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh_file</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh_obj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">process</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fix_normals</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">resistivity</span><span class="o">=</span><span class="default_value">1.6799999999999998e-08</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class that is used for surface mesh field calculations, e.g. coil design.
Computation functions are typically external functions that are called
using lazy properties.</p>
<p>The mesh surface can consist of a single contiguous surface or several separate
surfaces within a single mesh object. The Conductor object can handle data defined
on the mesh being represented in several different bases:</p>
<blockquote>
<div><ul class="simple">
<li><p>inner (default)</p></li>
<li><p>vertex:</p></li>
<li><p>suh: surface harmonics basis. Order given by N_suh</p></li>
</ul>
</div></blockquote>
<p>The bases can include built-in boundary conditions for the data: inner and
suh bases assume dirichlet boundary condition (equal value within each boundary),
while vertex basis does not set a boundary condition.</p>
<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.inductance">
<em class="property">property </em><code class="sig-name descname">inductance</code><a class="headerlink" href="#bfieldtools.conductor.Conductor.inductance" title="Permalink to this definition">¶</a></dt>
<dd><p>Self-inductance matrix, returned in appropiate basis.</p>
<p>For further information, see mesh_properties.self_inductance_matrix</p>
<p>property-decorated wrapper.</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.laplacian">
<em class="property">property </em><code class="sig-name descname">laplacian</code><a class="headerlink" href="#bfieldtools.conductor.Conductor.laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface laplacian matrix, returned in appropiate basis.</p>
<p>For further information, see mesh_calculus.laplacian_matrix</p>
<p>property-decorated wrapper.</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.mass">
<em class="property">property </em><code class="sig-name descname">mass</code><a class="headerlink" href="#bfieldtools.conductor.Conductor.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass matrix, returned in appropiate basis.</p>
<p>For further information, see mesh_calculus.mass_matrix</p>
<p>property-decorated wrapper.</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.mutual_inductance">
<code class="sig-name descname">mutual_inductance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">conductor_other</span></em>, <em class="sig-param"><span class="n">quad_degree</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">approx_far</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor.mutual_inductance" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutual inductance between this Conductor object and another</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>conductor_other: Conductor object</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>M: mutual inductance matrix M(self, other) in</dt><dd><p>in the bases specified in the conductor object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.plot_mesh">
<code class="sig-name descname">plot_mesh</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cull_front=False</em>, <em class="sig-param">cull_back=False</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor.plot_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply plot the mesh surface in mayavi. kwargs are passed to
viz.plot_mesh</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.resistance">
<em class="property">property </em><code class="sig-name descname">resistance</code><a class="headerlink" href="#bfieldtools.conductor.Conductor.resistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Resistance matrix. For further information, see mesh_properties.resistance_matrix</p>
<p>property-decorated wrapper.</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.save_pickle">
<code class="sig-name descname">save_pickle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">target_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Conductor object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.set_basis">
<code class="sig-name descname">set_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">basis_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor.set_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The data is stored in vertex basis i.e. every
element corresponds to one vertex. The basis matrix changes basis
of the operators so that a coefficient vector in the desired
basis can be multiplied directly with the operator</p>
<p>basis_names : str ‘vertex’, ‘inner’ or ‘suh’</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.set_holes">
<code class="sig-name descname">set_holes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">outer_boundaries</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.Conductor.set_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set indices of holes to self.holes</p>
<dl class="simple">
<dt>outer_boundaries: int or array_like, indices of outer boundaries in</dt><dd><p>self.boundaries. One boundary index per mesh component.
If None, outer_boundaries are set the longest
boundary in each mesh component</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.Conductor.sph_couplings">
<em class="property">property </em><code class="sig-name descname">sph_couplings</code><a class="headerlink" href="#bfieldtools.conductor.Conductor.sph_couplings" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical harmonic mappings from a stream function defined on the
Conductor mesh.</p>
<p>property-decorated wrapper</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfieldtools.conductor.CouplingMatrix">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">CouplingMatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.CouplingMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>General-use class that contains a data array (a coupling matrix)
and a bookkeeping list of computed points.</p>
<p>When called, returns the coupling matrix for queried points.
If some output has already been computed, use pre-computed values instead
and only compute missing parts.</p>
<dl class="py method">
<dt id="bfieldtools.conductor.CouplingMatrix.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.CouplingMatrix.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the coupling matrix and points</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfieldtools.conductor.StreamFunction">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">StreamFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_array</span></em>, <em class="sig-param"><span class="n">conductor</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.StreamFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<p>Class for representing stream function(s) on a conductor</p>
<p>Handles the mapping between different bases, e.g. inner vertices &lt;-&gt;
all vertices &lt;-&gt; surface harmonics</p>
<dl>
<dt>Parameters:</dt><dd><dl>
<dt>vals: array of shape (N,) or (N,M)</dt><dd><p>where N corresponds to
the number of inner vertices in the conductor or the
the number of all vertices in the conductor.</p>
<p>Multiple (M) stream functions can be stored in the object
by specifying vals with shape (N,M)</p>
</dd>
<dt>conductor:</dt><dd><p>Conductor object</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.discretize">
<code class="sig-name descname">discretize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">N_contours</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">contours</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method for contour.scalar_contour, turns the piecewise linear
stream function into isolines/contours in the form of polylines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N_contours: int</strong></dt><dd><p>Number of contours to generate</p>
</dd>
<dt><strong>contours: array-like</strong></dt><dd><p>Optional argument for manual input of contour levels. Overrides <cite>N_contours</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>contour_polys: list</dt><dd><p>list with length <cite>N_contours</cite>. Each list element is anumpy array containing the
coordinats of each polygon vertex.</p>
</dd>
<dt>contour_values: array-like</dt><dd><p>Vector containing the scalar function value for each contour line</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.inner">
<em class="property">property </em><code class="sig-name descname">inner</code><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the stream function in inner basis</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.magnetic_energy">
<em class="property">property </em><code class="sig-name descname">magnetic_energy</code><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.magnetic_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream-function magnetic energy</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">background=True</em>, <em class="sig-param">contours=False</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the stream function</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.power">
<em class="property">property </em><code class="sig-name descname">power</code><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream-function resistive power</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.conductor.StreamFunction.vert">
<em class="property">property </em><code class="sig-name descname">vert</code><a class="headerlink" href="#bfieldtools.conductor.StreamFunction.vert" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the stream function in vertex basis</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="bfieldtools.conductor.load_pickle">
<code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">load_pickle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load pickled Conductor object from file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to load from</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>obj: loaded Conductor object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.conductor.matrixwrapper">
<code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">matrixwrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.matrixwrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for lazy computation of Conductor matrices with basis change</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.conductor.save_pickle">
<code class="sig-prename descclassname">bfieldtools.conductor.</code><code class="sig-name descname">save_pickle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">target_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.conductor.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Conductor object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object to save to file</strong></dt><dd></dd>
<dt><strong>target_file: str</strong></dt><dd><p>file name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_properties">
<span id="bfieldtools-mesh-inductance-module"></span><h2>bfieldtools.mesh_inductance module<a class="headerlink" href="#module-bfieldtools.mesh_properties" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing the inductance matrices of triangle surface meshes,
including both self- and mutual-inductance.</p>
<dl class="py function">
<dt id="bfieldtools.mesh_properties.mesh2line_mutual_inductance">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">mesh2line_mutual_inductance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">line_vertices</span></em>, <em class="sig-param"><span class="n">quad_degree</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.mesh2line_mutual_inductance" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutual inductance of a closed line segment loop (last segment connecting to first)
and a triangle mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>line_vertices: points connected in index order (N_points, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>M: mutual inductance vector with shape (N_vertices,)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_properties.mutual_inductance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">mutual_inductance_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh1</span></em>, <em class="sig-param"><span class="n">mesh2</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quad_degree</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">approx_far</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">margin</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.mutual_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a mutual inductance matrix for hat basis functions
(stream functions) between two surface meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh1: Trimesh mesh object for mesh 1</strong></dt><dd></dd>
<dt><strong>mesh2: Trimesh mesh object for mesh 2</strong></dt><dd></dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>Number of serial chunks to divide the computation into</p>
</dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use. Self-inductance requires higher degree than mutual inductance</p>
</dd>
<dt><strong>approx_far: Boolean (True)</strong></dt><dd><p>If True, use approximate calculation for triangles that
far from the source triangles using a simple quadrature
(see integrals.triangle_potential_approx)</p>
</dd>
<dt><strong>margin: float</strong></dt><dd><p>Cut-off distance for “far” points measured in mean triangle side length</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>M: (Nvertices1 x Nvertices2) array</dt><dd><p>Mutual inductance matrix between mesh1 and mesh2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_properties.resistance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">resistance_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">sheet_resistance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.resistance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Resistance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>sheet_resistance: (N_faces) array or scalar</strong></dt><dd><p>“1/sigma*d” constant resistance for each face (or all faces if scalar)</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>R: (Nvertices x Nvertices) array</strong></dt><dd><p>resistance matrix of <cite>mesh</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_properties.self_inductance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">self_inductance_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quad_degree</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">approx_far</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">margin</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">chunk_clusters</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.self_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a self inductance matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>Number of serial chunks to divide the computation into</p>
</dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use. Self-inductance requires higher degree than mutual inductance</p>
</dd>
<dt><strong>approx_far: Boolean (True)</strong></dt><dd><p>If True, use approximate calculation for triangles that
far from the source triangles using a simple quadrature
(see integrals.triangle_potential_approx)</p>
</dd>
<dt><strong>margin: float</strong></dt><dd><p>Cut-off distance for “far” points measured in mean triangle side length</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>M: (Nvertices x Nvertices) array</strong></dt><dd><p>Self.inductance matrix of <cite>mesh</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.mesh_properties.triangle_self_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">triangle_self_coupling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.triangle_self_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Self-coupling integrated analytically. Implemented based on
Poole, M.S., 2007. Improved equipment and techniques for dynamic shimming in high field MRI (Doctoral dissertation, University of Nottingham.). page 72.</p>
<p>Self-coupling can be integrated analytically using different notation
<a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=475946">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=475946</a></p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.sphtools">
<span id="bfieldtools-sphtools-module"></span><h2>bfieldtools.sphtools module<a class="headerlink" href="#module-bfieldtools.sphtools" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="bfieldtools.sphtools.Blm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Blm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Blm" title="Permalink to this definition">¶</a></dt>
<dd><p>Blm vector function (see Eq. 19 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Blm: Nx3 array</strong></dt><dd><p>Blm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.Plm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Plm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Plm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plm vector function (see Eq. 18 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Plm: Nx3 array</strong></dt><dd><p>Plm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.Rotmatrix">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Rotmatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Rotmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs rotation matrix from cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vmat: 3x3 array</dt><dd><p>rotation matrix from cartesian to spherical.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.Vlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Vlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Vlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Vlm) for r**(-l) component of the magnetic field.
Normalization &lt;Vlm,Phikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Vlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Vlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Vlm: Nx3 array</dt><dd><p>Vlm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.Wlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Wlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Wlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Wlm) for r**l component of the magnetic field.
Normalization &lt;Wlm,Psikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Wlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Wlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Wlm: Nx3 array</strong></dt><dd><p>Wlm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.basis_fields">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">basis_fields</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.basis_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic fields for each sph coefficient.
Ignores the ‘DC’ component l=0. The fields are normalized
over the unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B1: N_lmax x N x 3 array</dt><dd><p>magnetic field at p for each alpha_lm</p>
</dd>
<dt>B2: N_lmax x N x 3 array</dt><dd><p>magnetic field at p for each beta_lm</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.cartesian2spherical">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">cartesian2spherical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">zaxis_approx</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.cartesian2spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>cartesian coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sp: Nx3 array</dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.cartvec2sph">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">cartvec2sph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sp</span></em>, <em class="sig-param"><span class="n">vec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.cartvec2sph" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>svec: Nx3 array</dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.compute_sphcoeffs_mesh">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">compute_sphcoeffs_mesh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.compute_sphcoeffs_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes multipole moment (spherical harmonics coefficient) transformation
from the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>alm: (lmax*(lmax+2)xNvertices array</dt><dd><p>transformation from the mesh to alm coefficients (r**l-terms)</p>
</dd>
<dt>blm: (lmax*(lmax+2)xNvertices array</dt><dd><p>transformation from the mesh to blm coefficients (r**(-l)-terms)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.derlpmn_em">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">derlpmn_em</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.derlpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes derivative of associated Legendre function (Plm) of the first kind of order m and degree l
with respect to the argument x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>derlp: Nx1 array</dt><dd><p>dPlm/dx at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.derxlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">derxlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.derxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Xlm with respect to theta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>derxlm: Nx1 array</dt><dd><p>dXlm/dtheta at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.dphiylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">dphiylm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.dphiylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to phi dYlm/dphi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dphiylm: Nx1 array</dt><dd><p>dYlm/dphi at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.dthylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">dthylm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.dthylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to theta dYlm/dtheta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dthylm: Nx1 array</dt><dd><p>dYlm/dtheta at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.field">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">acoeffs</span></em>, <em class="sig-param"><span class="n">bcoeffs</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.field" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic field from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>field: Nx3 array</dt><dd><p>magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.fitSpectra">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">fitSpectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="n">Bmeas</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.fitSpectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits spherical harmonics representation (r**l) to measured data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords: Nx3x3 array</strong></dt><dd><p>measurement coordinates, each measured field direction
in the third dimension: e.g. coords[:,:,2] gives the coordinates of measured z-components.</p>
</dd>
<dt><strong>Bmeas: Nx3 array</strong></dt><dd><p>the measured field values along different directions (x,y,z)</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the fit is done</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 array</dt><dd><p>the unnormalized coefficients</p>
</dd>
<dt>coeffs2: lmax*(lmax+2)x1 array</dt><dd><p>the ‘properly’ normalized squared coefficients</p>
</dd>
<dt>nrmse: float</dt><dd><p>normalized rms error in percents between the data and fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.lpmn_em">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">lpmn_em</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.lpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes associated Legendre function (Plm) of the first kind of order m and degree l.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>lp: Nx1 array</dt><dd><p>Plm at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotBVlm_volume">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotBVlm_volume</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">lim</span></em>, <em class="sig-param"><span class="n">Np</span></em>, <em class="sig-param"><span class="n">offset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotBVlm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Vlm’ (r**(-l)) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Vlm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotBWlm_volume">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotBWlm_volume</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">lim</span></em>, <em class="sig-param"><span class="n">Np</span></em>, <em class="sig-param"><span class="n">offset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotBWlm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Wlm’ (r**l) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Wlm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotVlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotVlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotVlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Vlm’ (r**(-l)) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotWlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotWlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotWlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Wlm’ (r**l) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotYlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotYlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotYlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics of order m and degree l.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.plotYlms">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotYlms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sph</span></em>, <em class="sig-param"><span class="n">lmax</span></em>, <em class="sig-param"><span class="n">polar</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotYlms" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics up to lmax.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l</p>
</dd>
<dt><strong>polar: boolean</strong></dt><dd><p>plot polar representation?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.potential">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">acoeffs</span></em>, <em class="sig-param"><span class="n">bcoeffs</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic scalar potential from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the potential is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pot: Nx1 array</dt><dd><p>magnetic scalar potential at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.reconstructB">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">reconstructB</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.reconstructB" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs the magnetic field using the spherical harmonics coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates where B is reconstructed</p>
</dd>
<dt><strong>coeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>the unnormalized l,m-coefficients</p>
</dd>
<dt><strong>lmax:int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nx3 array</dt><dd><p>reconstructed magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.sinxlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sinxlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sinxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes m/(sin(theta))*Xlm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sinxlm: Nx1 array</dt><dd><p>m/(sin(theta))*Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="bfieldtools.sphtools.sphbasis">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sphbasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Np</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for constructing spherical harmonics (Ylms), their gradients
and related magnetic field ‘basis vectorfunctions’
(Wlms for r**l components, Vlms for r**(-l) components).</p>
<p>Uses notations and definitions by Plattner and Simons (2014; <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>)
and the same normalization conventions.</p>
<p>Integration over a surface of unit sphere is
used as the inner product &lt;C,D&gt; = int C dot D dOmega.</p>
<p>Has also lot of functions for spherical &lt;-&gt; cartesian transformations.</p>
<p>TODO: mu0 might be missing!!!</p>
<dl class="py method">
<dt id="bfieldtools.sphtools.sphbasis.avsphspectra">
<code class="sig-name descname">avsphspectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.avsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**l-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 arrays</dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.sphtools.sphbasis.bvsphspectra">
<code class="sig-name descname">bvsphspectra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">lmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.bvsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**(-l)-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 arrays</dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.sphtools.sphbasis.initqp">
<code class="sig-name descname">initqp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.initqp" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises quadrature points on the sphere.</p>
<p>Default points are McLaren(10) so that we avoid singularities.</p>
</dd></dl>

<dl class="py method">
<dt id="bfieldtools.sphtools.sphbasis.innerproduct">
<code class="sig-name descname">innerproduct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fun1</span></em>, <em class="sig-param"><span class="n">fun2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.innerproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of vector functions fun1 and fun2.
Defined as integration over a surface of unit sphere &lt;C,D&gt; = int C dot D dOmega.
Quadrature rule defined in qp is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun1: Nx3 array</strong></dt><dd><p>vector function 1</p>
</dd>
<dt><strong>fun2: Nx3 array</strong></dt><dd><p>vector function 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dotp: int</dt><dd><p>inner product of fun1 and fun2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.spherical2cartesian">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">spherical2cartesian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.spherical2cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps spherical coordinates to cartesian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>p: Nx3 array</dt><dd><p>cartesian croodinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.sphvec2cart">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sphvec2cart</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sp</span></em>, <em class="sig-param"><span class="n">vec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphvec2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>svec: Nx3 array</dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.xlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">xlm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.xlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Xlm-function used in the definition of spherical harmonics (Ylm).
Follows notation of Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Xlm: Nx1 array</dt><dd><p>Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.sphtools.ylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">ylm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">phi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.ylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Real spherical harmonics as defined by Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Ylm: Nx1 array</dt><dd><p>Ylm at (theta,phi)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.thermal_noise">
<span id="bfieldtools-thermal-noise-module"></span><h2>bfieldtools.thermal_noise module<a class="headerlink" href="#module-bfieldtools.thermal_noise" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing thermal noise in conductive thin objects.</p>
<dl class="py function">
<dt id="bfieldtools.thermal_noise.compute_ac_Bnoise">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_ac_Bnoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">freqs</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">T</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_ac_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the AC magnetic noise due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfrequencies x Nfieldpoints x 3components array</dt><dd><p>magnetic RMS noise across frequencies</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.compute_current_modes">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_current_modes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">boundaries</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_eigenvals</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eddy-current modes for a mesh using surface laplacian.
Uses Dirichlet boundary condition, i.e., stream function is zero at boundary:
no current flow outside the surface.
The modes are normalized so that the squared norm of the stream function gradient
integrates to 1 over the surface. With this normalization, the resistances
of the current modes are R_k = 1/(sigma*d), sigma = conductivity, d = thickness.
See Zevenhoven et al. (2014).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>boundaries: list of N_holes</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vl: Nvertices x Nvertices array</dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.compute_current_modes_ind_res">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_current_modes_ind_res</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">R</span></em>, <em class="sig-param"><span class="n">freqs</span></em>, <em class="sig-param"><span class="n">T</span></em>, <em class="sig-param"><span class="n">closed</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">Nmodes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_eigenvals</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_current_modes_ind_res" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>M: (Nvertices x Nvertices) array</strong></dt><dd><p>The self-inductance matrix of <cite>mesh</cite></p>
</dd>
<dt><strong>R: (Nvertices x Nvertices) array</strong></dt><dd><p>The resistance matrix of <cite>mesh</cite></p>
</dd>
<dt><strong>freqs: Nfreqs array</strong></dt><dd><p>The frequencies at which the eddy-current modes are computed</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature in Kelvins</p>
</dd>
<dt><strong>closed: boolean</strong></dt><dd><p>Is the mesh closed (True) or not (False)</p>
</dd>
<dt><strong>Nmodes: int</strong></dt><dd><p>How many modes are computed? If None, all Nvertices modes are computed</p>
</dd>
<dt><strong>return_eigenvals: boolean</strong></dt><dd><p>Return also the eigenvalues (the inverse circuit time constants)?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vl: (Nvertices x Nmodes x Nfreqs) array</dt><dd><p>The spectral eddy-current modes</p>
</dd>
<dt>u: Nmodes array</dt><dd><p>The eigenvalues (the inverse circuit time constants)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_dc_Bnoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">T</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfieldpoints x 3components array</dt><dd><p>magnetic RMS noise at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_dc_Bnoise_covar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">T</span></em>, <em class="sig-param"><span class="n">Nchunks</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise covariance at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfieldpoints x Nfieldpoints x 3components array</dt><dd><p>magnetic noise covariance at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.integrate_Bnoise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">integrate_Bnoise_covar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">B_covar</span></em>, <em class="sig-param"><span class="n">weighting</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.integrate_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the (quadrature) integrated noise over a volume spanned by the points in fp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B_covar: (N_p, N_p, 3) array</strong></dt><dd><p>One vector component of the covariance matrix computed by compute_dc_Bnoise_covar</p>
</dd>
<dt><strong>weighting: (N_p,) array</strong></dt><dd><p>Weighting factors for each point in the volume. If None (default), use equal weighting.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Bnoise_integrated: float</dt><dd><p>Integrated noise amplitude over the volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.noise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_covar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">B_coupling</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">Nmodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_covar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.noise_covar_dir">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_covar_dir</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">B_coupling</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">Nmodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_covar_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.noise_var">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">B_coupling</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">Nmodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="bfieldtools.thermal_noise.visualize_current_modes">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">visualize_current_modes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">vl</span></em>, <em class="sig-param"><span class="n">Nmodes</span></em>, <em class="sig-param"><span class="n">scale</span></em>, <em class="sig-param"><span class="n">contours</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">colormap</span><span class="o">=</span><span class="default_value">'bwr'</span></em>, <em class="sig-param"><span class="n">dist</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.visualize_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualizes current modes up to Nmodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>Nmodes: int</strong></dt><dd><p>Number of modes to be plotted</p>
</dd>
<dt><strong>scale: float</strong></dt><dd><p>Scaling factor</p>
</dd>
<dt><strong>contours: boolean</strong></dt><dd><p>If True, show contours</p>
</dd>
<dt><strong>colormap: string</strong></dt><dd><p>Which (matplotlib) colormap to use</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.utils">
<span id="bfieldtools-utils-module"></span><h2>bfieldtools.utils module<a class="headerlink" href="#module-bfieldtools.utils" title="Permalink to this headline">¶</a></h2>
<p>This module contains miscellaneous utility functions used across bfieldtools.</p>
<dl class="py function">
<dt id="bfieldtools.utils.combine_meshes">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">combine_meshes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">meshes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.combine_meshes" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two or more non-overlapping Trimesh meshes without any dependency
requirements. For more demanding applications, use Trimesh boolean operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshes: list or tuple</strong></dt><dd><p>Each element should be a Trimesh mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>combined_mesh: Trimesh mesh</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.cylinder_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">cylinder_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">length</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">nlength</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">360</span></em>, <em class="sig-param"><span class="n">nalpha</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">array([0, 0, 0])</span></em>, <em class="sig-param"><span class="n">orientation</span><span class="o">=</span><span class="default_value">array([1, 0, 0])</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.cylinder_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return a set of points on a cylindrical surface.</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.dual_areas">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">dual_areas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tris</span></em>, <em class="sig-param"><span class="n">ta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.dual_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (dual) areas for each node in inds</p>
<p>Dual area == area summed over the neighbouring triangles divided by 3</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.find_mesh_boundaries">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">find_mesh_boundaries</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.find_mesh_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the open boundaries of a mesh by finding the edges that only
belong to a single triangle. Returns an index array of inner vertices
and triangles that do not touch the outer boundary.
Takes edge parameter for convenience.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: trimesh mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>boundaries: list of array-like</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.fix_normals">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">fix_normals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">array([0, 0, 0])</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to fix face windings and normals such that normals are always “pointing out”
from the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>origin: array-like (3, )</strong></dt><dd><p>Specified from where the normals should “point out”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>mesh: modified Trimesh object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.get_line_quad_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">get_line_quad_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">line_vertices</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'midpoint'</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.get_line_quad_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get quad points and weights from quadrature rules implemented in
quadpy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>line_vertices: array-like [Nverts x 3]</strong></dt><dd><p>Assumes vertices are connected according to index, last index connects to first</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>w: array-like  (Nquad, )</dt><dd><p>quadrature weights</p>
</dd>
<dt>qp: array-like (Nverts, Nquad)</dt><dd><p>quadrature points for each edge connecting the vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.get_quad_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">get_quad_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verts</span></em>, <em class="sig-param"><span class="n">tris</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'sevenpoint'</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.get_quad_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get quad points and weights from quadrature rules implemented in
quadpy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts: array-like [Nverts x 3]</strong></dt><dd></dd>
<dt><strong>tris: array-like [Ntris x 3]</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>w: array-like  (Nquad, )</dt><dd><p>quadrature weights</p>
</dd>
<dt>qp: array-like (Ntris, Nquad)</dt><dd><p>quadrature points in each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.inner2vert">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">inner2vert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">inner_vertices</span></em>, <em class="sig-param"><span class="n">holes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.inner2vert" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear mapping of the inner (free) weights in the stream function
discretization to weights in all vertices</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>mesh: Trimesh object
inner_vertices: list of indices of the inner vertices of the mesh
holes: list of indices for holes in the mesh</p>
</dd>
<dt>Returns:</dt><dd><p>NxM sparse array, where N==mesh.vertices.shape[0]
and M == len(inner_vertices) + len(holes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.load_example_mesh">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">load_example_mesh</code><span class="sig-paren">(</span><em class="sig-param">mesh_name</em>, <em class="sig-param">process=True</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.load_example_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function used load example meshes included with the package</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh_name: string</strong></dt><dd><p>name of mesh, i.e. filename without extension</p>
</dd>
<dt><strong>process: Boolean</strong></dt><dd><p>Whether trimesh should process the mesh on loading</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Passed to trimesh object creation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Trimesh object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.tri_normals_and_areas">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">tri_normals_and_areas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">tri</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.tri_normals_and_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get triangle normals and areas from vertices (r) and
triangle indices (tri)</p>
</dd></dl>

<dl class="py function">
<dt id="bfieldtools.utils.vert2inner">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">vert2inner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mesh</span></em>, <em class="sig-param"><span class="n">inner_vertices</span></em>, <em class="sig-param"><span class="n">holes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.vert2inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear mapping of the all weights in the stream function
discretization to inner (free) weights</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>mesh: Trimesh object
inner_vertices: list of indices of the inner vertices of the mesh
holes: list of indices for holes in the mesh</p>
</dd>
<dt>Returns:</dt><dd><p>MxN sparse array, where N==mesh.vertices.shape[0]
and M == len(inner_vertices) + len(holes)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019, bfieldtools developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>