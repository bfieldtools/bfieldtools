<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>bfieldtools package &#8212; bfieldtools 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="API Reference" href="modules.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          bfieldtools</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../readme.html">Readme</a></li>
                <li><a href="../literature.html">Literature</a></li>
                <li><a href="../auto_examples/index.html">Example gallery</a></li>
                <li><a href="modules.html">API Reference</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Readme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../literature.html">Literature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Example gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#coil-design">Coil design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#thermal-noise-computation">Thermal noise computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#validation">Validation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Reference</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="bfieldtools-package">
<h1>bfieldtools package<a class="headerlink" href="#bfieldtools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bfieldtools.line_magnetics">
<span id="bfieldtools-line-magnetics-module"></span><h2>bfieldtools.line_magnetics module<a class="headerlink" href="#module-bfieldtools.line_magnetics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.line_magnetics.cross">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">cross</code><span class="sig-paren">(</span><em class="sig-param">r1</em>, <em class="sig-param">r2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross product without overhead</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.flux">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">flux</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">loops</em>, <em class="sig-param">vertices_other</em>, <em class="sig-param">Nquad=2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute magnetic flux created by a segmented line current loops
(vertices, loops) on a another closed loop of segmented current
(vertices_other). The other loop is numerically integrated.</p>
<p>In other words, calculate mutual inductance of the current loops.</p>
<p>NOT SUITABLE for calculating the self-flux, i.e., self inductance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices:</strong></dt><dd><p>all vertices in segmented loops generating the flux</p>
</dd>
<dt><strong>loops:</strong></dt><dd><p>list of indices defining closed loops of vertices, if
None use all vertices. All loops must have the same
number of indices (this could be changed in future)
Example: Giving array of 4 vertices, the loops can be
defined as loops = np.array([[0,1,2,3]])</p>
</dd>
<dt><strong>vertices_other:</strong></dt><dd><p>vertices in the loop receiving the flux</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>flux in the other loop generated by loops (Nloops,)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.magnetic_field">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">magnetic_field</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.magnetic_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute b field of a segmented line current.
This calculation is based on integration by Griffiths
on page 217 (3rd edition)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points:   (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bfield: (N_points, 3) array</dt><dd><p>Magnetic field at evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.magnetic_field2">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">magnetic_field2</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.magnetic_field2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute b field of a segmented line current.
See:
Compact expressions for the Biot–Savart fields of a filamentary segments
by Hanson &amp; Hirshman</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points:   (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bfield: (N_points, 3) array</dt><dd><p>Magnetic field at evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.magnetic_field_current_loops">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">magnetic_field_current_loops</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">points</em>, <em class="sig-param">loops</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.magnetic_field_current_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>B field for segmented current loops</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
<dt><strong>loops: list</strong></dt><dd><p>list of ordered indices defining closed loops of vertices,
if None use all vertices in the order of vertices.
Example: Giving array of 4 vertices, the closed loop can be
defined as loops = np.array([[0,1,2,3,0]])</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.scalar_potential">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">scalar_potential</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.scalar_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the scalar magnetic potential of a segmented current loop at given points.
This is equal to the solid angle spanned by the loop (polygon), times a constant.
The first and last vertices are connected to close the loop.
Parameters
———-
vertices: (N_line, 3) array</p>
<blockquote>
<div><p>Vertices of the line with N_line-1 segments</p>
</div></blockquote>
<dl class="simple">
<dt>points: (N_points, 3) array</dt><dd><p>Magnetic field evaluation points</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Scalar magnetic potential (Npoints, )</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.line_magnetics.vector_potential">
<code class="sig-prename descclassname">bfieldtools.line_magnetics.</code><code class="sig-name descname">vector_potential</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">points</em>, <em class="sig-param">loops=None</em>, <em class="sig-param">reg=1e-12</em>, <em class="sig-param">symmetrize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.line_magnetics.vector_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential of a segmented line currents.
Based on straightforward integration of 1/r potential over a line
i.e. the gamma0 integral</p>
<dl class="simple">
<dt>See:</dt><dd><p>Compact expressions for the Biot–Savart fields of a filamentary segments
by Hanson &amp; Hirshman</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices: (N_line, 3) array</strong></dt><dd><p>Vertices of the line with N_line-1 segments</p>
</dd>
<dt><strong>points: (N_points, 3) array</strong></dt><dd><p>Magnetic field evaluation points</p>
</dd>
<dt><strong>loops: list</strong></dt><dd><p>list of ordered indices defining closed loops of vertices,
if None use all vertices in the order of vertices.
All loops must have the same number of indices
(this could be changed in future)
Example: Giving array of 4 vertices, a closed loop can be
defined as loops = np.array([[0,1,2,3]])</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Vector potential (Nloops, Npoints, 3)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.coil_optimize">
<span id="bfieldtools-coil-optimize-module"></span><h2>bfieldtools.coil_optimize module<a class="headerlink" href="#module-bfieldtools.coil_optimize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.coil_optimize.cvxopt_solve_qp">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">cvxopt_solve_qp</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">q</em>, <em class="sig-param">G=None</em>, <em class="sig-param">h=None</em>, <em class="sig-param">A=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">sw=None</em>, <em class="sig-param">reg=None</em>, <em class="sig-param">tolerance=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxopt_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use cvxopt to minimize
(1/2) * x’ * P * x + q’ * x</p>
<p>subject to
G * x &lt;= h</p>
<p>and
A * x = b</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.cvxpy_solve_qp">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">cvxpy_solve_qp</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">G</em>, <em class="sig-param">h</em>, <em class="sig-param">solver=cvxpy.MOSEK</em>, <em class="sig-param">tolerance=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.cvxpy_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.optimize_streamfunctions">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">optimize_streamfunctions</code><span class="sig-paren">(</span><em class="sig-param">conductor</em>, <em class="sig-param">bfield_specification</em>, <em class="sig-param">objective='minimum_inductive_energy'</em>, <em class="sig-param">solver=None</em>, <em class="sig-param">solver_opts={}</em>, <em class="sig-param">problem=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.optimize_streamfunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadratic optimization of coil stream function according to a specified objective,
while keeping specified target field at target points within given constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>conductor: Conductor object</strong></dt><dd><p>Contains Trimesh mesh</p>
</dd>
<dt><strong>bfield_specification: list</strong></dt><dd><p>List in which element is a dictionary containing a field specification.
Each dict contains:
coupling: Coupling matrix (N_r, N_verts, 3)
target: (N_r, 3)
abs_error: float or (N_r, 3)
rel_error: float or (N_r, 3)</p>
</dd>
<dt><strong>objective: string or dict</strong></dt><dd><p>if string, either ‘minimum_inductive_energy’ or ‘minimum_resistive_energy’
if tuple, should contain: (a, b), where a and b are floats describing the inductive and resitive weighting factors.
The resistance matrix is scaled according to the largest singular value of the inductance matrix for consistent behavior
across meshes.</p>
</dd>
<dt><strong>solver: string</strong></dt><dd><p>string specifying which solver CVXPy will use</p>
</dd>
<dt><strong>solver_opt: dict</strong></dt><dd><p>dict containing solver options CVXPY will pass to the solver</p>
</dd>
<dt><strong>problem: CVXPY problem object</strong></dt><dd><p>If passed, will use already existing problem (MUST BE SAME DIMENSIONS) to
skip DCP processing/reformulation time.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>s: vector</dt><dd><p>Vector with length len(<cite>conductor.mesh.vertices</cite>), containing the optimized current density values
at each mesh vertex</p>
</dd>
<dt>prob: CVXPY problem object</dt><dd><p>CVXPY problem object containing data, formulation, solution, metric etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.coil_optimize.quadprog_solve_qp">
<code class="sig-prename descclassname">bfieldtools.coil_optimize.</code><code class="sig-name descname">quadprog_solve_qp</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">q</em>, <em class="sig-param">G=None</em>, <em class="sig-param">h=None</em>, <em class="sig-param">A=None</em>, <em class="sig-param">b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.coil_optimize.quadprog_solve_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use quadprog to minimize
(1/2) * x’ * P * x + q’ * x</p>
<p>subject to
G * x &lt;= h</p>
<p>and
A * x = b</p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.contour">
<span id="bfieldtools-contour-module"></span><h2>bfieldtools.contour module<a class="headerlink" href="#module-bfieldtools.contour" title="Permalink to this headline">¶</a></h2>
<p>This module includes functions for creating contours (isolines) of a scalar function
defined on a triangle mesh surface. Also contains functions for modifying the generated contours.</p>
<dl class="function">
<dt id="bfieldtools.contour.scalar_contour">
<code class="sig-prename descclassname">bfieldtools.contour.</code><code class="sig-name descname">scalar_contour</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">scalars</em>, <em class="sig-param">N_contours=10</em>, <em class="sig-param">contours=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.scalar_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes contour loops (isolines) for a scalar function defined on a mesh.
The winding direction of the loops is defined according to the rotated gradient of the scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd><p>Trimesh object containing the mesh on which the scalar function is defined</p>
</dd>
<dt><strong>scalars: array-like</strong></dt><dd><p>Vector containing the values of the scalar function at each of the mesh vertices</p>
</dd>
<dt><strong>N_contours: int</strong></dt><dd><p>Number of contours to generate</p>
</dd>
<dt><strong>contours: array-like</strong></dt><dd><p>Optional argument for manual input of contour levels. Overrides <cite>N_contours</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>contour_polys: list</dt><dd><p>list with length <cite>N_contours</cite>. Each list element is anumpy array containing the
coordinats of each polygon vertex.</p>
</dd>
<dt>contour_values: array-like</dt><dd><p>Vector containing the scalar function value for each contour line</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.contour.simplify_contour">
<code class="sig-prename descclassname">bfieldtools.contour.</code><code class="sig-name descname">simplify_contour</code><span class="sig-paren">(</span><em class="sig-param">c</em>, <em class="sig-param">min_edge=0.001</em>, <em class="sig-param">angle_threshold=0.02</em>, <em class="sig-param">smooth=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.contour.simplify_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies contours by merging small (short) segments and
with only a small angle difference.</p>
<p>Optionally applies smoothing to contour shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c: list</strong></dt><dd><p>List of polygons describing closed loops.</p>
</dd>
<dt><strong>min_edge: float</strong></dt><dd><p>Minimum edge length. Edges shorter than this are merged.</p>
</dd>
<dt><strong>angle_threshold: float</strong></dt><dd><p>Minimum angle. Edges with smaller angle differences are merged.</p>
</dd>
<dt><strong>smooth: bool</strong></dt><dd><p>If True, apply smoothing to the polygon shapes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>c: list</dt><dd><p>Modified list of polygons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_calculus">
<span id="bfieldtools-mesh-calculus-module"></span><h2>bfieldtools.mesh_calculus module<a class="headerlink" href="#module-bfieldtools.mesh_calculus" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing geometric/vector calculus quantities of triangle surface meshes,
such as the gradient, divergence, curl, Laplacian and  mass matrices.</p>
<dl class="function">
<dt id="bfieldtools.mesh_calculus.curl">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">curl</code><span class="sig-paren">(</span><em class="sig-param">vecs</em>, <em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.curl" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint curl applied to tangential vector field</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.curl_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">curl_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.curl_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint curl of tangential vector field</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.divergence">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">divergence</code><span class="sig-paren">(</span><em class="sig-param">vecs</em>, <em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Divergence mapping applied to tangential vector field</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.divergence_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">divergence_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.divergence_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Divergence of tangential vector field as linear mappings</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.gradient">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">vals</em>, <em class="sig-param">mesh</em>, <em class="sig-param">rotated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies mesh (rotated) gradient matrix operator on vector that is
defined in the vertex locations of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vals: Nv x 1 array of scalar data to compute the gradient of</strong></dt><dd></dd>
<dt><strong>mesh: Trimesh object describing the triangular mesh</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>gradient (3, Ntris)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.gradient_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">gradient_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">rotated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.gradient_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a (rotated) gradient matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>rotated: boolean</strong></dt><dd><p>If True, rotate gradient 90 degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Gx ,Gy, Gx (Ntris, Nverts) matrices</dt><dd><p>for calculating the components of gradient at triangles</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.laplacian_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">laplacian_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">material_param=None</em>, <em class="sig-param">inner_vertices=None</em>, <em class="sig-param">holes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.laplacian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse Laplace(-Beltrami) operator</p>
<p>If holes are present, mesh vertices not present in inner_vertices or holes
are assumed to be on the outer boundary of the mesh, which is set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
<dt><strong>material_param: array-like with length N_triangles</strong></dt><dd><p>material parameter for each triangle</p>
</dd>
<dt><strong>inner_vertices: list (default None)</strong></dt><dd><p>contains mesh vertex indices corresponding to inner holes</p>
</dd>
<dt><strong>holes: list with length N_holes (default None)</strong></dt><dd><p>each list element contains array-like of mesh vertex indices corresponding to each
mesh hole</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Cotangent weights: w_ij = - 0.5* (cot(alpha) + cot(beta))</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_calculus.mass_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_calculus.</code><code class="sig-name descname">mass_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">lumped=False</em>, <em class="sig-param">inner_vertices=None</em>, <em class="sig-param">holes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_calculus.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mass matrix of mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh Mesh object</strong></dt><dd></dd>
<dt><strong>da: Pre-computed dual areas</strong></dt><dd><p>Optionally, provide pre-computed dual areas</p>
</dd>
<dt><strong>lumped: Boolean</strong></dt><dd><p>If True, use lumped approximation of mass matrix. If False (default),
compute exact matrix. See Reuters et al 2009, page 3 (DOI: 10.1016/j.cag.2009.03.005)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Mesh mass matrix (Nvertices, Nvertices)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_magnetics">
<span id="bfieldtools-mesh-magnetics-module"></span><h2>bfieldtools.mesh_magnetics module<a class="headerlink" href="#module-bfieldtools.mesh_magnetics" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for calculating the coupling of surface current density in a
triangle mesh to magnetic field as well as scalar and vector potentials.</p>
<dl class="function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">r</em>, <em class="sig-param">Nchunks=None</em>, <em class="sig-param">quad_degree=1</em>, <em class="sig-param">analytic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: (Np, 3, Nvertices) array</dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling_analytic</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">r</em>, <em class="sig-param">Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing the mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: (Np, 3, Nvertices) array</dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic_old">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">magnetic_field_coupling_analytic_old</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">r</em>, <em class="sig-param">Nchunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.magnetic_field_coupling_analytic_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh, computes the “C matrix” which gives the magnetic field at
some target points due to currents (stream function) on a surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing the mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>C: (Np, 3, Nvertices) array</dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_magnetics.scalar_potential_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">scalar_potential_coupling</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">r</em>, <em class="sig-param">Nchunks=None</em>, <em class="sig-param">multiply_coeff=True</em>, <em class="sig-param">approx_far=False</em>, <em class="sig-param">margin=3</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.scalar_potential_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scalar potential matrix from linear stream functions
using analytic integral</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object describing mesh</strong></dt><dd></dd>
<dt><strong>r: target points (Np, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U: (Np, 3, Nvertices) array</dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_magnetics.vector_potential_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_magnetics.</code><code class="sig-name descname">vector_potential_coupling</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">r</em>, <em class="sig-param">Nchunks=None</em>, <em class="sig-param">approx_far=True</em>, <em class="sig-param">margin=2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_magnetics.vector_potential_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vector potential matrices (one for each coordinate)
from linear stream functions using analytic integral
Parameters
———-</p>
<p>mesh: Trimesh mesh object describing mesh
r: target points (Np, 3)
approx_far: Boolean (True)</p>
<blockquote>
<div><p>If True, use approximate calculation for triangles that are not close to r</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>A: (Np, 3, Nvertices) array</dt><dd><p>Coupling matrix for surface current in the mesh to the evaluation points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_class">
<span id="bfieldtools-mesh-class-module"></span><h2>bfieldtools.mesh_class module<a class="headerlink" href="#module-bfieldtools.mesh_class" title="Permalink to this headline">¶</a></h2>
<p>Contains a class used for wrapping a mesh (in the form of a Trimesh object) together with
some convenient functions and properties.</p>
<dl class="class">
<dt id="bfieldtools.mesh_class.Conductor">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">Conductor</code><span class="sig-paren">(</span><em class="sig-param">verts=None</em>, <em class="sig-param">tris=None</em>, <em class="sig-param">mesh_file=None</em>, <em class="sig-param">mesh_obj=None</em>, <em class="sig-param">process=False</em>, <em class="sig-param">fix_normals=True</em>, <em class="sig-param">resistivity=1.6799999999999998e-08</em>, <em class="sig-param">thickness=0.0001</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class that is used for surface mesh field calculations, e.g. coil design.
Computation functions are typically external functions that are called
using lazy properties.</p>
<p>The mesh surface can consist of a single contiguous surface or several separate
surfaces within a single mesh object.</p>
<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.inductance">
<em class="property">property </em><code class="sig-name descname">inductance</code><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.inductance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.laplacian">
<em class="property">property </em><code class="sig-name descname">laplacian</code><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.laplacian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.mass">
<em class="property">property </em><code class="sig-name descname">mass</code><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.mass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.mutual_inductance">
<code class="sig-name descname">mutual_inductance</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">conductor_other</em>, <em class="sig-param">quad_degree=1</em>, <em class="sig-param">approx_far=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.mutual_inductance" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutual inductance between this conductor and another</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>conductor_other: Conductor object</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>M: mutual inductance matrix M(self, other) in</dt><dd><p>in the bases specified in the conductor object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.plot_mesh">
<code class="sig-name descname">plot_mesh</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cull_front=False</em>, <em class="sig-param">cull_back=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.plot_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply plot the mesh surface in mayavi.</p>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.resistance">
<em class="property">property </em><code class="sig-name descname">resistance</code><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.resistance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.save_pickle">
<code class="sig-name descname">save_pickle</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Conductor object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.set_basis">
<code class="sig-name descname">set_basis</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">basis_name</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.set_basis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.set_holes">
<code class="sig-name descname">set_holes</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">outer_boundaries=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.set_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set indices of holes to self.holes</p>
<dl class="simple">
<dt>outer_boundaries: int or array_like, indices of outer boundaries in</dt><dd><p>self.boundaries. One boundary index per mesh component.
If None, outer_boundaries are set the longest
boundary in each mesh component</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.Conductor.sph_couplings">
<em class="property">property </em><code class="sig-name descname">sph_couplings</code><a class="headerlink" href="#bfieldtools.mesh_class.Conductor.sph_couplings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="bfieldtools.mesh_class.CouplingMatrix">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">CouplingMatrix</code><span class="sig-paren">(</span><em class="sig-param">parent</em>, <em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.CouplingMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>General-use class that contains a data array (a coupling matrix)
and a bookkeeping list of computed points.</p>
<p>When called, returns the coupling matrix for queried points.
If some output has already been computed, use pre-computed values instead
and only compute missing parts.</p>
<dl class="method">
<dt id="bfieldtools.mesh_class.CouplingMatrix.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.CouplingMatrix.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the matrix and points</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="bfieldtools.mesh_class.LazyProperty">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">LazyProperty</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.LazyProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Implementation of lazily loading properties, see
<a class="reference external" href="http://blog.pythonisito.com/2008/08/lazy-descriptors.html">http://blog.pythonisito.com/2008/08/lazy-descriptors.html</a>
On first invocation, a lazy property calls a function that populates
the property (acts as a method). Afterwards, it acts like a normal property.</p>
</dd></dl>

<dl class="class">
<dt id="bfieldtools.mesh_class.StreamFunction">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">StreamFunction</code><span class="sig-paren">(</span><em class="sig-param">input_array</em>, <em class="sig-param">conductor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<p>Class for representing stream function(s) on a conductor</p>
<p>Handles the mapping between the inner (free) weights in the
stream function and the all vertices</p>
<dl>
<dt>Parameters:</dt><dd><dl>
<dt>vals:</dt><dd><blockquote>
<div><p>array of shape (N,) or (N,M) where N corresponds to
the number of inner vertices in the conductor or the
the number of all vertices in the conductor.</p>
</div></blockquote>
<p>Multiple (M) stream functions can be stored in the object
by specifying vals with shape (N,M)</p>
</dd>
<dt>conductor:</dt><dd><p>Conductor object</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.discretize">
<code class="sig-name descname">discretize</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">N_contours=10</em>, <em class="sig-param">contours=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method for scalar_contour</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N_contours: int</strong></dt><dd><p>Number of contours to generate</p>
</dd>
<dt><strong>contours: array-like</strong></dt><dd><p>Optional argument for manual input of contour levels. Overrides <cite>N_contours</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>contour_polys: list</dt><dd><p>list with length <cite>N_contours</cite>. Each list element is anumpy array containing the
coordinats of each polygon vertex.</p>
</dd>
<dt>contour_values: array-like</dt><dd><p>Vector containing the scalar function value for each contour line</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.inner">
<em class="property">property </em><code class="sig-name descname">inner</code><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.inner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.magnetic_energy">
<em class="property">property </em><code class="sig-name descname">magnetic_energy</code><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.magnetic_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">background=True</em>, <em class="sig-param">contours=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the stream function</p>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.power">
<em class="property">property </em><code class="sig-name descname">power</code><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.power" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="bfieldtools.mesh_class.StreamFunction.vert">
<em class="property">property </em><code class="sig-name descname">vert</code><a class="headerlink" href="#bfieldtools.mesh_class.StreamFunction.vert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_class.load_pickle">
<code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">load_pickle</code><span class="sig-paren">(</span><em class="sig-param">target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load pickled Conductor object from file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target_file: str</strong></dt><dd><p>File name or file object to load from</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>obj: loaded Conductor object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_class.matrixwrapper">
<code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">matrixwrapper</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.matrixwrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for lazy computation of Conductor matrices with basis change</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_class.save_pickle">
<code class="sig-prename descclassname">bfieldtools.mesh_class.</code><code class="sig-name descname">save_pickle</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">target_file</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_class.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Conductor object using a pickled Python file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object to save to file</strong></dt><dd></dd>
<dt><strong>target_file: str</strong></dt><dd><p>file name or file object to save to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.mesh_properties">
<span id="bfieldtools-mesh-inductance-module"></span><h2>bfieldtools.mesh_inductance module<a class="headerlink" href="#module-bfieldtools.mesh_properties" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing the inductance matrices of triangle surface meshes,
including both self- and mutual-inductance.</p>
<dl class="function">
<dt id="bfieldtools.mesh_properties.mesh2line_mutual_inductance">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">mesh2line_mutual_inductance</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">line_vertices</em>, <em class="sig-param">quad_degree=3</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.mesh2line_mutual_inductance" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutual inductance of a closed line segment loop (last segment connecting to first)
and a triangle mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>line_vertices: points connected in index order (N_points, 3)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>M: mutual inductance vector with shape (N_vertices,)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_properties.mutual_inductance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">mutual_inductance_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh1</em>, <em class="sig-param">mesh2</em>, <em class="sig-param">Nchunks=None</em>, <em class="sig-param">quad_degree=1</em>, <em class="sig-param">approx_far=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.mutual_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a mutual inductance matrix for hat basis functions
(stream functions) between two surface meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh1: Trimesh mesh object for mesh 1</strong></dt><dd></dd>
<dt><strong>mesh2: Trimesh mesh object for mesh 2</strong></dt><dd></dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>Number of serial chunks to divide the computation into</p>
</dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use. Self-inductance requires higher degree than mutual inductance</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>M: (Nvertices1 x Nvertices2) array</dt><dd><p>Mutual inductance matrix between mesh1 and mesh2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_properties.resistance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">resistance_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">sheet_resistance</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.resistance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Resistance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>sheet_resistance: (N_faces) array or scalar</strong></dt><dd><p>“1/sigma*d” constant resistance for each face (or all faces if scalar)</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>R: (Nvertices x Nvertices) array</strong></dt><dd><p>resistance matrix of <cite>mesh</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_properties.self_inductance_matrix">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">self_inductance_matrix</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">Nchunks=None</em>, <em class="sig-param">quad_degree=2</em>, <em class="sig-param">approx_far=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.self_inductance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a self inductance matrix for hat basis functions
(stream functions) in the triangular mesh described by</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>Nchunks: int</strong></dt><dd><p>Number of serial chunks to divide the computation into</p>
</dd>
<dt><strong>quad_degree: int &gt;= 1</strong></dt><dd><p>Quadrature degree (Dunavant scheme) to use. Self-inductance requires higher degree than mutual inductance</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>M: (Nvertices x Nvertices) array</strong></dt><dd><p>Self.inductance matrix of <cite>mesh</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.mesh_properties.triangle_self_coupling">
<code class="sig-prename descclassname">bfieldtools.mesh_properties.</code><code class="sig-name descname">triangle_self_coupling</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.mesh_properties.triangle_self_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: Self coupling can be integrated analytically
<a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=475946">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=475946</a></p>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.sphtools">
<span id="bfieldtools-sphtools-module"></span><h2>bfieldtools.sphtools module<a class="headerlink" href="#module-bfieldtools.sphtools" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bfieldtools.sphtools.Blm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Blm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Blm" title="Permalink to this definition">¶</a></dt>
<dd><p>Blm vector function (see Eq. 19 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Blm: Nx3 array</strong></dt><dd><p>Blm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.Philm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Philm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Philm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Philm) for r**(-l) component of the magnetic field.
Normalization &lt;Philm,Phikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Philm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Philm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Philm: Nx3 array</dt><dd><p>Philm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.Plm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Plm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Plm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plm vector function (see Eq. 18 Plattner and Simons (2014)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Plm: Nx3 array</strong></dt><dd><p>Plm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.Psilm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Psilm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Psilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector basis function (Psilm) for r**l component of the magnetic field.
Normalization &lt;Psilm,Psikn&gt; = delta_lk,mn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Psilm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Psilm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>Psilm: Nx3 array</strong></dt><dd><p>Psilm at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.Rotmatrix">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">Rotmatrix</code><span class="sig-paren">(</span><em class="sig-param">sp</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.Rotmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs rotation matrix from cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vmat: 3x3 array</dt><dd><p>rotation matrix from cartesian to spherical.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.basis_fields">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">basis_fields</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.basis_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic fields for each sph coefficient.
Ignores the ‘DC’ component l=0. The fields are normalized
over the unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B1: N_lmax x N x 3 array</dt><dd><p>magnetic field at p for each alpha_lm</p>
</dd>
<dt>B2: N_lmax x N x 3 array</dt><dd><p>magnetic field at p for each beta_lm</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.cartesian2spherical">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">cartesian2spherical</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">zaxis_approx=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.cartesian2spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps cartesian coordinates to spherical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>cartesian coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sp: Nx3 array</dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.cartvec2sph">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">cartvec2sph</code><span class="sig-paren">(</span><em class="sig-param">sp</em>, <em class="sig-param">vec</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.cartvec2sph" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>svec: Nx3 array</dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.compute_sphcoeffs_mesh">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">compute_sphcoeffs_mesh</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.compute_sphcoeffs_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes multipole moment (spherical harmonics coefficient) transformation
from the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>alm: (lmax*(lmax+2)xNvertices array</dt><dd><p>transformation from the mesh to alm coefficients (r**l-terms)</p>
</dd>
<dt>blm: (lmax*(lmax+2)xNvertices array</dt><dd><p>transformation from the mesh to blm coefficients (r**(-l)-terms)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.derlpmn_em">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">derlpmn_em</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.derlpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes derivative of associated Legendre function (Plm) of the first kind of order m and degree l
with respect to the argument x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>derlp: Nx1 array</dt><dd><p>dPlm/dx at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.derxlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">derxlm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.derxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Xlm with respect to theta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>derxlm: Nx1 array</dt><dd><p>dXlm/dtheta at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.dphiylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">dphiylm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.dphiylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to phi dYlm/dphi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dphiylm: Nx1 array</dt><dd><p>dYlm/dphi at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.dthylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">dthylm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.dthylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of Ylm with respect to theta dYlm/dtheta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dthylm: Nx1 array</dt><dd><p>dYlm/dtheta at (theta, phi).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.field">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">field</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">acoeffs</em>, <em class="sig-param">bcoeffs</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.field" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic field from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the field is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>field: Nx3 array</dt><dd><p>magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.fitSpectra">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">fitSpectra</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">Bmeas</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.fitSpectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits spherical harmonics representation (r**l) to measured data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords: Nx3x3 array</strong></dt><dd><p>measurement coordinates, each measured field direction
in the third dimension: e.g. coords[:,:,2] gives the coordinates of measured z-components.</p>
</dd>
<dt><strong>Bmeas: Nx3 array</strong></dt><dd><p>the measured field values along different directions (x,y,z)</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the fit is done</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 array</dt><dd><p>the unnormalized coefficients</p>
</dd>
<dt>coeffs2: lmax*(lmax+2)x1 array</dt><dd><p>the ‘properly’ normalized squared coefficients</p>
</dd>
<dt>nrmse: float</dt><dd><p>normalized rms error in percents between the data and fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.lpmn_em">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">lpmn_em</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.lpmn_em" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes associated Legendre function (Plm) of the first kind of order m and degree l.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Plm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Plm</p>
</dd>
<dt><strong>x: Nx1 array</strong></dt><dd><p>evaluation points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>lp: Nx1 array</dt><dd><p>Plm at <cite>x</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotBPhilm_volume">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotBPhilm_volume</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">lim</em>, <em class="sig-param">Np</em>, <em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotBPhilm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Philm’ (r**(-l)) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Philm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotBPsilm_volume">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotBPsilm_volume</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">lim</em>, <em class="sig-param">Np</em>, <em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotBPsilm_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Psilm’ (r**l) over a 3D volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
<dt><strong>lim: float</strong></dt><dd><p>limits for coordinates, e.g., xmin = -lim, xmax = lim</p>
</dd>
<dt><strong>Np: int</strong></dt><dd><p>number of points along different coordinates</p>
</dd>
<dt><strong>offset: 1x3 array</strong></dt><dd><p>offset of the volume in which Psilm is plotted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotPhilm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotPhilm</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">l</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotPhilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Philm’ (r**(-l)) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotPsilm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotPsilm</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">l</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotPsilm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots magnetic field basis function ‘Psilm’ (r**l) over a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>obj: mayavi object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotYlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotYlm</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">l</em>, <em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotYlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics of order m and degree l.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>l: int</strong></dt><dd><p>degree l</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order m</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.plotYlms">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">plotYlms</code><span class="sig-paren">(</span><em class="sig-param">sph</em>, <em class="sig-param">lmax</em>, <em class="sig-param">polar=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.plotYlms" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots real spherical harmonics up to lmax.
Inspired by <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html">https://docs.enthought.com/mayavi/mayavi/auto/example_spherical_harmonics.html</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sph: spherical harmonics analysis object</strong></dt><dd></dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l</p>
</dd>
<dt><strong>polar: boolean</strong></dt><dd><p>plot polar representation?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.potential">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">potential</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">acoeffs</em>, <em class="sig-param">bcoeffs</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes magnetic scalar potential from the sph coefficients.
Ignores the ‘DC’ component l=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates in which the potential is computed</p>
</dd>
<dt><strong>acoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**l terms</p>
</dd>
<dt><strong>bcoeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>spectral coefficients of r**(-l) terms</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l which is used in computing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pot: Nx1 array</dt><dd><p>magnetic scalar potential at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.reconstructB">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">reconstructB</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">coeffs</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.reconstructB" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs the magnetic field using the spherical harmonics coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p: Nx3 array</strong></dt><dd><p>coordinates where B is reconstructed</p>
</dd>
<dt><strong>coeffs: lmax*(lmax+2)x1 array</strong></dt><dd><p>the unnormalized l,m-coefficients</p>
</dd>
<dt><strong>lmax:int</strong></dt><dd><p>maximum degree l of the fit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nx3 array</dt><dd><p>reconstructed magnetic field at p</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.sinxlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sinxlm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sinxlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes m/(sin(theta))*Xlm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>sinxlm: Nx1 array</dt><dd><p>m/(sin(theta))*Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="bfieldtools.sphtools.sphbasis">
<em class="property">class </em><code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sphbasis</code><span class="sig-paren">(</span><em class="sig-param">Np</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for constructing spherical harmonics (Ylms), their gradients
and related magnetic field ‘basis vectorfunctions’
(Psilms for r**l components, Philms for r**(-l) components).</p>
<p>Uses notations and definitions by Plattner and Simons (2014; <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>)
and the same normalization conventions.</p>
<p>Integration over a surface of unit sphere is
used as the inner product &lt;C,D&gt; = int C dot D dOmega.</p>
<p>Has also lot of functions for spherical &lt;-&gt; cartesian transformations.</p>
<p>TODO: mu0 might be missing!!!</p>
<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.avsphspectra">
<code class="sig-name descname">avsphspectra</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fun</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.avsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**l-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 arrays</dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.bvsphspectra">
<code class="sig-name descname">bvsphspectra</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fun</em>, <em class="sig-param">lmax</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.bvsphspectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the l,m-spectra (over r**(-l)-terms) of vector function defined in quadrature points
using the inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun: Nx3 array</strong></dt><dd><p>vector function computed at quadrature points self.sqp</p>
</dd>
<dt><strong>lmax: int</strong></dt><dd><p>maximum degree l for which the spectra is computed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>coeffs: lmax*(lmax+2)x1 arrays</dt><dd><p>spectral coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.initqp">
<code class="sig-name descname">initqp</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.initqp" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises quadrature points on the sphere.</p>
<p>Default points are McLaren(10) so that we avoid singularities.</p>
</dd></dl>

<dl class="method">
<dt id="bfieldtools.sphtools.sphbasis.innerproduct">
<code class="sig-name descname">innerproduct</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fun1</em>, <em class="sig-param">fun2</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphbasis.innerproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of vector functions fun1 and fun2.
Defined as integration over a surface of unit sphere &lt;C,D&gt; = int C dot D dOmega.
Quadrature rule defined in qp is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun1: Nx3 array</strong></dt><dd><p>vector function 1</p>
</dd>
<dt><strong>fun2: Nx3 array</strong></dt><dd><p>vector function 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dotp: int</dt><dd><p>inner product of fun1 and fun2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.spherical2cartesian">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">spherical2cartesian</code><span class="sig-paren">(</span><em class="sig-param">sp</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.spherical2cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps spherical coordinates to cartesian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>p: Nx3 array</dt><dd><p>cartesian croodinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.sphvec2cart">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">sphvec2cart</code><span class="sig-paren">(</span><em class="sig-param">sp</em>, <em class="sig-param">vec</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.sphvec2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cartesian vector to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sp: Nx3 array</strong></dt><dd><p>spherical coordinates [r, theta, phi]</p>
</dd>
<dt><strong>vec: Nx3 array</strong></dt><dd><p>vector in spherical coordinates [e_r, e_theta, e_phi]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>svec: Nx3 array</dt><dd><p>vector in cartesian coordinates [e_x, e_y, e_z]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.xlm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">xlm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.xlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Xlm-function used in the definition of spherical harmonics (Ylm).
Follows notation of Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Xlm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Xlm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Xlm: Nx1 array</dt><dd><p>Xlm at theta</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.sphtools.ylm">
<code class="sig-prename descclassname">bfieldtools.sphtools.</code><code class="sig-name descname">ylm</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">m</em>, <em class="sig-param">theta</em>, <em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.sphtools.ylm" title="Permalink to this definition">¶</a></dt>
<dd><p>Real spherical harmonics as defined by Plattner and Simons (2014);
see Eqs. 1–3 in <a class="reference external" href="https://arxiv.org/pdf/1306.3201.pdf">https://arxiv.org/pdf/1306.3201.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l: int</strong></dt><dd><p>degree of Ylm</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>order of Ylm</p>
</dd>
<dt><strong>theta: Nx1 array</strong></dt><dd><p>evaluation points, theta at spherical coordinates</p>
</dd>
<dt><strong>phi: Nx1 array</strong></dt><dd><p>evaluation points, phi at spherical coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Ylm: Nx1 array</dt><dd><p>Ylm at (theta,phi)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.thermal_noise">
<span id="bfieldtools-thermal-noise-module"></span><h2>bfieldtools.thermal_noise module<a class="headerlink" href="#module-bfieldtools.thermal_noise" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for computing thermal noise in conductive thin objects.</p>
<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_ac_Bnoise">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_ac_Bnoise</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">vl</em>, <em class="sig-param">fp</em>, <em class="sig-param">freqs</em>, <em class="sig-param">sigma</em>, <em class="sig-param">d</em>, <em class="sig-param">T</em>, <em class="sig-param">Nchunks=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_ac_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the AC magnetic noise due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfrequencies x Nfieldpoints x 3components array</dt><dd><p>magnetic RMS noise across frequencies</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_current_modes">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_current_modes</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">boundaries=None</em>, <em class="sig-param">return_eigenvals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eddy-current modes for a mesh using surface laplacian.
Uses Dirichlet boundary condition, i.e., stream function is zero at boundary:
no current flow outside the surface.
The modes are normalized so that the squared norm of the stream function gradient
integrates to 1 over the surface. With this normalization, the resistances
of the current modes are R_k = 1/(sigma*d), sigma = conductivity, d = thickness.
See Zevenhoven et al. (2014).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>boundaries: list of N_holes</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vl: Nvertices x Nvertices array</dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_current_modes_ind_res">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_current_modes_ind_res</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">sheet_resistance</em>, <em class="sig-param">freqs</em>, <em class="sig-param">T</em>, <em class="sig-param">closed=True</em>, <em class="sig-param">Nmodes=100</em>, <em class="sig-param">Nchunks=4</em>, <em class="sig-param">quad_degree=2</em>, <em class="sig-param">boundaries=None</em>, <em class="sig-param">return_eigenvals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_current_modes_ind_res" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>boundaries: list of N_holes</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vl: Nvertices x Nvertices array</dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_dc_Bnoise</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">vl</em>, <em class="sig-param">fp</em>, <em class="sig-param">sigma</em>, <em class="sig-param">d</em>, <em class="sig-param">T</em>, <em class="sig-param">Nchunks=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfieldpoints x 3components array</dt><dd><p>magnetic RMS noise at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.compute_dc_Bnoise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">compute_dc_Bnoise_covar</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">vl</em>, <em class="sig-param">fp</em>, <em class="sig-param">sigma</em>, <em class="sig-param">d</em>, <em class="sig-param">T</em>, <em class="sig-param">Nchunks=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.compute_dc_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the magnetic noise covariance at DC due to thermal motion of charge carriers (Jonhson-Nyquist noise)
in a relatively thin conductor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object - the surface mesh</strong></dt><dd></dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>fp: Nfieldpoints x 3 array</strong></dt><dd><p>Coordinates of the fieldpoints</p>
</dd>
<dt><strong>sigma: float</strong></dt><dd><p>Conductivity of the surface</p>
</dd>
<dt><strong>d: float</strong></dt><dd><p>Thickness of the surface</p>
</dd>
<dt><strong>T: float</strong></dt><dd><p>Temperature of the surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>B: Nfieldpoints x Nfieldpoints x 3components array</dt><dd><p>magnetic noise covariance at DC</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.integrate_Bnoise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">integrate_Bnoise_covar</code><span class="sig-paren">(</span><em class="sig-param">B_covar</em>, <em class="sig-param">weighting=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.integrate_Bnoise_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the (quadrature) integrated noise over a volume spanned by the points in fp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>B_covar: (N_p, N_p, 3) array</strong></dt><dd><p>One vector component of the covariance matrix computed by compute_dc_Bnoise_covar</p>
</dd>
<dt><strong>weighting: (N_p,) array</strong></dt><dd><p>Weighting factors for each point in the volume. If None (default), use equal weighting.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Bnoise_integrated: float</dt><dd><p>Integrated noise amplitude over the volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.noise_covar">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_covar</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">B_coupling</em>, <em class="sig-param">vl</em>, <em class="sig-param">Nmodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_covar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.noise_covar_dir">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_covar_dir</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">B_coupling</em>, <em class="sig-param">vl</em>, <em class="sig-param">Nmodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_covar_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.noise_var">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">noise_var</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">B_coupling</em>, <em class="sig-param">vl</em>, <em class="sig-param">Nmodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.noise_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bfieldtools.thermal_noise.visualize_current_modes">
<code class="sig-prename descclassname">bfieldtools.thermal_noise.</code><code class="sig-name descname">visualize_current_modes</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">vl</em>, <em class="sig-param">Nmodes</em>, <em class="sig-param">scale</em>, <em class="sig-param">contours=True</em>, <em class="sig-param">colormap='bwr'</em>, <em class="sig-param">dist=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.thermal_noise.visualize_current_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualizes current modes up to Nmodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd><p>The surface mesh</p>
</dd>
<dt><strong>vl: Nvertices x Nvertices array</strong></dt><dd><p>The normalized eddy-current modes vl[:,i]</p>
</dd>
<dt><strong>Nmodes: int</strong></dt><dd><p>Number of modes to be plotted</p>
</dd>
<dt><strong>scale: float</strong></dt><dd><p>Scaling factor</p>
</dd>
<dt><strong>contours: boolean</strong></dt><dd><p>If True, show contours</p>
</dd>
<dt><strong>colormap: string</strong></dt><dd><p>Which (matplotlib) colormap to use</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bfieldtools.utils">
<span id="bfieldtools-utils-module"></span><h2>bfieldtools.utils module<a class="headerlink" href="#module-bfieldtools.utils" title="Permalink to this headline">¶</a></h2>
<p>This module contains miscellaneous utility functions used across bfieldtools.</p>
<dl class="function">
<dt id="bfieldtools.utils.assemble_matrix">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">assemble_matrix</code><span class="sig-paren">(</span><em class="sig-param">tris</em>, <em class="sig-param">Nverts</em>, <em class="sig-param">triangle_data</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.assemble_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.assemble_matrix2">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">assemble_matrix2</code><span class="sig-paren">(</span><em class="sig-param">tris1</em>, <em class="sig-param">tris2</em>, <em class="sig-param">Nverts1</em>, <em class="sig-param">Nverts2</em>, <em class="sig-param">triangle_data</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.assemble_matrix2" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data for separate meshes 1 and 2</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.assemble_matrix_chunk">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">assemble_matrix_chunk</code><span class="sig-paren">(</span><em class="sig-param">tris</em>, <em class="sig-param">Nverts</em>, <em class="sig-param">triangle_data</em>, <em class="sig-param">n</em>, <em class="sig-param">Nchunks</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.assemble_matrix_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized  assembly of finite element matrix for
precomputed triangle data. Version for computation in which eval points
are chunked smaller, less memory-intensive parts</p>
<p>Sums the triangle_data [Ntris (1), Ntris (2), 3 (nodes 1),3 (nodes 2)]
for the nodes neighbouring the triangle</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.cylinder_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">cylinder_points</code><span class="sig-paren">(</span><em class="sig-param">radius=1</em>, <em class="sig-param">length=1</em>, <em class="sig-param">nlength=10</em>, <em class="sig-param">alpha=360</em>, <em class="sig-param">nalpha=10</em>, <em class="sig-param">center=array([0</em>, <em class="sig-param">0</em>, <em class="sig-param">0])</em>, <em class="sig-param">orientation=array([1</em>, <em class="sig-param">0</em>, <em class="sig-param">0])</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.cylinder_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return a set of points on a cylindrical surface.</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.dual_areas">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">dual_areas</code><span class="sig-paren">(</span><em class="sig-param">tris</em>, <em class="sig-param">ta</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.dual_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (dual) areas for each node in inds</p>
<p>Dual area == area summed over the neighbouring triangles divided by 3</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.fibonacci_sphere">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">fibonacci_sphere</code><span class="sig-paren">(</span><em class="sig-param">samples=10</em>, <em class="sig-param">center=array([0</em>, <em class="sig-param">0</em>, <em class="sig-param">0])</em>, <em class="sig-param">radius=1</em>, <em class="sig-param">randomize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.fibonacci_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a set of points approximately evenly distributed on a sphere,
with adjustable center and radius. Uses spherical Fibonacci Lattice.</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.find_mesh_boundaries">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">find_mesh_boundaries</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.find_mesh_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the open boundaries of a mesh by finding the edges that only
belong to a single triangle. Returns an index array of inner vertices
and triangles that do not touch the outer boundary.
Takes edge parameter for convenience.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: trimesh mesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>boundaries: list of array-like</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.fix_normals">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">fix_normals</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">origin=array([0</em>, <em class="sig-param">0</em>, <em class="sig-param">0])</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to fix face windings and normals such that normals are always “pointing out”
from the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh mesh object</strong></dt><dd></dd>
<dt><strong>origin: array-like (3, )</strong></dt><dd><p>Specified from where the normals should “point out”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>mesh: modified Trimesh object</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.get_line_quad_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">get_line_quad_points</code><span class="sig-paren">(</span><em class="sig-param">line_vertices</em>, <em class="sig-param">method='midpoint'</em>, <em class="sig-param">index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.get_line_quad_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get quad points and weights from quadrature rules implemented in
quadpy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>line_vertices: array-like [Nverts x 3]</strong></dt><dd><p>Assumes vertices are connected according to index, last index connects to first</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>w: array-like  (Nquad, )</dt><dd><p>quadrature weights</p>
</dd>
<dt>qp: array-like (Nverts, Nquad)</dt><dd><p>quadrature points for each edge connecting the vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.get_quad_points">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">get_quad_points</code><span class="sig-paren">(</span><em class="sig-param">verts</em>, <em class="sig-param">tris</em>, <em class="sig-param">method='sevenpoint'</em>, <em class="sig-param">index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.get_quad_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get quad points and weights from quadrature rules implemented in
quadpy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts: array-like [Nverts x 3]</strong></dt><dd></dd>
<dt><strong>tris: array-like [Ntris x 3]</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>w: array-like  (Nquad, )</dt><dd><p>quadrature weights</p>
</dd>
<dt>qp: array-like (Ntris, Nquad)</dt><dd><p>quadrature points in each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.inner2vert">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">inner2vert</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">inner_vertices</em>, <em class="sig-param">holes</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.inner2vert" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear mapping of the inner (free) weights in the stream function
discretization to weights in all vertices</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>mesh: Trimesh object
inner_vertices: list of indices of the inner vertices of the mesh
holes: list of indices for holes in the mesh</p>
</dd>
<dt>Returns:</dt><dd><p>NxM sparse array, where N==mesh.vertices.shape[0]
and M == len(inner_vertices) + len(holes)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.tri_normals_and_areas">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">tri_normals_and_areas</code><span class="sig-paren">(</span><em class="sig-param">r</em>, <em class="sig-param">tri</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.tri_normals_and_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get triangle normals and areas from vertices (r) and
triangle indices (tri)</p>
</dd></dl>

<dl class="function">
<dt id="bfieldtools.utils.vert2inner">
<code class="sig-prename descclassname">bfieldtools.utils.</code><code class="sig-name descname">vert2inner</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">inner_vertices</em>, <em class="sig-param">holes</em><span class="sig-paren">)</span><a class="headerlink" href="#bfieldtools.utils.vert2inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear mapping of the all weights in the stream function
discretization to inner (free) weights</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>mesh: Trimesh object
inner_vertices: list of indices of the inner vertices of the mesh
holes: list of indices for holes in the mesh</p>
</dd>
<dt>Returns:</dt><dd><p>MxN sparse array, where N==mesh.vertices.shape[0]
and M == len(inner_vertices) + len(holes)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019, bfieldtools developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>